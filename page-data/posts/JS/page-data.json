{"componentChunkName":"component---src-templates-category-template-js","path":"/posts/JS","result":{"pageContext":{"currentCategory":"JS","categories":["All","JS","Book"],"edges":[{"node":{"id":"c494ff70-31c5-535d-813b-1f5ec6540936","excerpt":"1. flat() 배열 차원을 변환하고 새로운 배열로 설정하여 반환 파라미터의 대상 깊이에 따라 변환이 다름 파라미터에 을 작성한 경우 파라미터에 을 작성 빈 엘리먼트를 삭제 2. flatMap()  와 기본 기능은 같음 배열을 반복하면서 콜백 함수 호출 파라미터 : 엘리먼트, 인덱스, 배열 전체 콜백 함수에서 반환한 값을 배열로 반환  과 차이 1. flat() 2. flatMap()","fields":{"slug":"/study-js-es6-array-6/"},"frontmatter":{"categories":"JS","title":"flat(), flatMap()","date":"October 04, 2021"}},"next":{"fields":{"slug":"/study-js-es6-array-5/"}},"previous":null},{"node":{"id":"492f979e-a5f3-5d0d-97a9-6fce4a69db73","excerpt":"1. fill() 범위 값을 지정한 값으로 설정, 반환 설정 방법 시작 인덱스부터 끝 인덱스 직전까지 첫 번째 파라미터 값으로 설정(대체) Generic 함수 2. includes() 대상 배열에 첫 번째 파라미터 값이 있으면 , 없으면 를 반환 두 번째 파라미터는 선택이며 비교 시작 인덱스 작성 제네릭 함수 1. fill() 2. includes()","fields":{"slug":"/study-js-es6-array-5/"},"frontmatter":{"categories":"JS","title":"fill(), includes()","date":"October 03, 2021"}},"next":{"fields":{"slug":"/study-js-es6-array-3/"}},"previous":{"fields":{"slug":"/study-js-es6-array-6/"}}},{"node":{"id":"f8a5c3e4-1b9b-554b-ab76-750b7455ffef","excerpt":"Generic 스펙에서 아래 문장을 볼 수 있음  ES7 스펙, 22.1.3.3    사용 형태 의 뜻하는 것은? 이  메소드이므로  오브젝트가 처리 대상이지만 은  오브젝트가 아닌 , 를 처리할 수 있다는 것을 뜻함 Generic","fields":{"slug":"/study-js-es6-array-3/"},"frontmatter":{"categories":"JS","title":"Generic","date":"October 02, 2021"}},"next":{"fields":{"slug":"/study-js-es6-array-4/"}},"previous":{"fields":{"slug":"/study-js-es6-array-5/"}}},{"node":{"id":"ef43d290-5e72-5643-97d1-34b59ded1b5d","excerpt":"1. find() 배열의 엘리먼트를 하나씩 읽어가면서 콜백 함수 호출 파라미터 : 엘리먼트, 인덱스, 배열 전체 콜백 함수에서 를 반환하면 를 종료하면서 현재 처리중인 엘리먼트 값을 반환 2. findIndex() 배열의 엘리먼트를 하나씩 읽어가면서 콜백 함수 호출 파라미터 : 엘리먼트, 인덱스, 배열 전체 콜백 함수에서  반환하면  종료하면서 현재 처리 중인 엘리먼트의 인덱스를 반환 1. find() 2. findIndex()","fields":{"slug":"/study-js-es6-array-4/"},"frontmatter":{"categories":"JS","title":"find(), findIndex()","date":"October 02, 2021"}},"next":{"fields":{"slug":"/read-book-2/"}},"previous":{"fields":{"slug":"/study-js-es6-array-3/"}}},{"node":{"id":"c5eb811a-06b3-5a4f-8b13-9da184880c8c","excerpt":"1. copyWithin() 범위 값을 복사하여 같은 오브젝트에 설정 두 번째 파라미터의 인덱스부터 복사하여 첫 번째 파라미터 인덱스 부터 순서대로 설정(대체) 세 번째 파라미터의 인덱스 직전까지 복사 복사 시작 인덱스와 끝 인덱스를 작성하지 않으면 배열 전체 복사 2. copyWithin()  함수의 특징  같은 배열 안에서 이동하는 개념 배열의 엘리먼트 수가 변동되지 않음 배열 안에서 엘리먼트를 이동은 엘리먼트를 왼쪽, 오른쪽으로 이동하는 것(처리 속도가 빠름) 1. copyWithin() 2. copyWithin()","fields":{"slug":"/study-js-es6-array-2/"},"frontmatter":{"categories":"JS","title":"배열 엘리먼트 복사, copyWithin()","date":"October 01, 2021"}},"next":{"fields":{"slug":"/study-js-es6-array-1/"}},"previous":{"fields":{"slug":"/read-book-2/"}}},{"node":{"id":"0f644301-ee6b-5d96-ae52-83d684b1a4a3","excerpt":"1. from() 첫 번째 파라미터의 오브젝트를  오브젝트로 변환 두 번째 파라미터에 함수 작성 이터러블 오브젝트를 전개할 때마다 호출 세 번째 파라미터에 오브젝트 작성 호출된 함수에서 로 참조 2. of() 함수 파라미터 값을 로 변환, 반환 파라미터에 변환 대상 값을 작성 콤마로 구분하여 다수 작성 가능 1. from() 2. of() 함수","fields":{"slug":"/study-js-es6-array-1/"},"frontmatter":{"categories":"JS","title":"from(), of()","date":"September 30, 2021"}},"next":{"fields":{"slug":"/study-js-es6-template-literal-3/"}},"previous":{"fields":{"slug":"/study-js-es6-array-2/"}}},{"node":{"id":"d93ed896-c2ad-5dce-8dd8-29055b87495f","excerpt":"1. String.raw  오브젝트에 속하지만 을 사용하므로 여기서 다룸 에 이어서  작성 줄 바꿈을 문자로 처리 유니코드의 코드 포인트 처리 2. String.raw() 의 문자열을 문자 하나씩 전개 하면서 두 번째 파라미터 부터 조합하고 연결 문자열 배열 첫 번째 파라미터는  형태 두 번째 파라미터 부터 조합할 값 작성  1. String.raw 2. String.raw()","fields":{"slug":"/study-js-es6-template-literal-3/"},"frontmatter":{"categories":"JS","title":"String.raw, String.raw()","date":"September 29, 2021"}},"next":{"fields":{"slug":"/study-js-es6-template-literal-2/"}},"previous":{"fields":{"slug":"/study-js-es6-array-1/"}}},{"node":{"id":"4c1cbd4e-2093-5a31-aa17-fb55f0bd87d3","excerpt":"tagged Template 템플릿에 함수 이름을 작성한 형태 호출되는 함수를 라고 부름  함수를 호출하면서 문자열을 배열로 파라미터로 넘기고 표현식 결과를 하나씩 파라미터로 넘김 호출하는 곳에서 표현식을 평가한 값을 다수 넘겨 줄 때 태그 함수에 대응하는 파라미터 이름을 작성한 형태 문자열을 분리하면  3개의 배열 엘리먼트가 됨 표현식을 분리하면 와  show 태그 함수를 호출 태그 함수에 Rest 파라미터 작성 문자열을 분리하면  3개의 배열 엘리먼트가 됨 표현식을 분리하면 와   show 태그 함수를 호출 tagged Template","fields":{"slug":"/study-js-es6-template-literal-2/"},"frontmatter":{"categories":"JS","title":"tagged Template","date":"September 28, 2021"}},"next":{"fields":{"slug":"/study-js-es6-template-literal-1/"}},"previous":{"fields":{"slug":"/study-js-es6-template-literal-3/"}}},{"node":{"id":"735861e5-1ad2-5bed-8a3b-c7f5ff2d9fcc","excerpt":"Template Literal Syntax   tag  Template Literal 문자열 처리를 위한 리터럴 표현식을 포함할 수 있음 강좌에서는 템플릿으로 표기  안에 표현식 작성 표현식을  형태로 작성 줄 바꿈 작성 차이 Template Literal","fields":{"slug":"/study-js-es6-template-literal-1/"},"frontmatter":{"categories":"JS","title":"Template Literal","date":"September 27, 2021"}},"next":{"fields":{"slug":"/study-js-es6-object-5/"}},"previous":{"fields":{"slug":"/study-js-es6-template-literal-2/"}}},{"node":{"id":"f1340f31-1055-57e2-9bb9-d6da9ade70f0","excerpt":"메소드 호출 방법 과 에 연결된 메소드를 호출하는 방법이 다름 에 연결된 메소드 호출  처럼 을 작성하여 호출 에 연결된 메소드 호출 인스턴스를 생성하여 호출  연산자로 생성한 인스턴스 구조 메소드 호출 방법","fields":{"slug":"/study-js-es6-object-5/"},"frontmatter":{"categories":"JS","title":"prototype와 proto, 메소드 호출 방법","date":"September 26, 2021"}},"next":{"fields":{"slug":"/study-js-es6-object-6/"}},"previous":{"fields":{"slug":"/study-js-es6-template-literal-1/"}}},{"node":{"id":"ab437056-27d7-5d7d-91e5-d7301502b0ca","excerpt":"함수로 추가  연산자로 인스턴스를 생성하고 인스턴스의 프로퍼티로 함수를 추가 다른 인스턴스와 공유하지 않음 인스턴스에 추가한 후의 인스턴스 구조 함수로 추가","fields":{"slug":"/study-js-es6-object-6/"},"frontmatter":{"categories":"JS","title":"인스턴스에 함수로 추가","date":"September 26, 2021"}},"next":{"fields":{"slug":"/study-js-es6-object-7/"}},"previous":{"fields":{"slug":"/study-js-es6-object-5/"}}},{"node":{"id":"3a07726a-3e7e-5938-bf3f-519ce8f18654","excerpt":"메소드 추가  에 을 추가하면 에 설정되며 메소드로 추가하는 것과 같음 에 추가한 후의  모습 추가한 메소드를 인스턴스에 공유 메소드 추가","fields":{"slug":"/study-js-es6-object-7/"},"frontmatter":{"categories":"JS","title":"__proto__에 메소드 추가","date":"September 26, 2021"}},"next":{"fields":{"slug":"/study-js-es6-object-8/"}},"previous":{"fields":{"slug":"/study-js-es6-object-6/"}}},{"node":{"id":"bfcab37b-31cc-5aa2-831d-c1c39e36fe16","excerpt":"setPorotytpeOf() 첫 번째 파라미터의으로 두 번째 파라미터를 설정 첫 번째 파라미터에 인스턴스 작성  실행 후 인스턴스 구조 ES5에 가 있음 setPorotytpeOf()","fields":{"slug":"/study-js-es6-object-8/"},"frontmatter":{"categories":"JS","title":"setPrototypeOf() - 인스턴스 사용","date":"September 26, 2021"}},"next":{"fields":{"slug":"/study-js-es6-object-9/"}},"previous":{"fields":{"slug":"/study-js-es6-object-7/"}}},{"node":{"id":"b9b7cf46-f3c3-5307-af62-e7a42e3c1873","excerpt":"setPorotytpeOf() 첫 번째 파라미터에 을 작성 첫 번째 파라미터의 에 두 번째 파라미터의 에 연결된 프로퍼티를 설정  연결 후의 인스턴스 구조 상속을 위한 목적이라면  등의 상속 처리 키워드를 제공하는 를 사용하는 것이 좋음 setPorotytpeOf()","fields":{"slug":"/study-js-es6-object-9/"},"frontmatter":{"categories":"JS","title":"setPrototypeOf() - prototype 사용","date":"September 26, 2021"}},"next":{"fields":{"slug":"/study-js-es6-object-4/"}},"previous":{"fields":{"slug":"/study-js-es6-object-8/"}}},{"node":{"id":"bd27811e-1fcf-5f4c-85ff-1dfc72933441","excerpt":"1. entries() 열거 가능한 오브젝트의 를  형태로 변환 작성한 순서가 바뀌는 경우 문자열은 문자 하나씩 분리 2. values() 열거 가능한 오브젝트의 를  형태로 변환 작성한 순서가 바뀌는 경우 문자열은 문자 하나씩 분리 3. fromEntires()  형태를  형태로 변환 프로퍼티 키 값이 같으면 값 대체 4. getOwnPropertyDescriptors() 의 프로퍼티 디스크립터를 반환 데이터 디스크립터 액세스 디스크립터 상속받은 오브젝트는 반환하지 않음 1. entries() 2. values() 3. fromEntires() 4. getOwnPropertyDescriptors()","fields":{"slug":"/study-js-es6-object-4/"},"frontmatter":{"categories":"JS","title":"Object 변환","date":"September 25, 2021"}},"next":{"fields":{"slug":"/study-js-es6-object-3/"}},"previous":{"fields":{"slug":"/study-js-es6-object-9/"}}},{"node":{"id":"5bd56bd9-8a9d-5f6b-a44d-f6cd4e67e1a4","excerpt":"Deep Copyt Object를 할당하면 프로퍼티 값이 연동됨 한 쪽 오브젝트의 프로퍼티 값을 바꾸면, 다른 오브젝트의 프로퍼티 값도 바뀜  함수로 복사 그래도 연동되는 형태 연동되지 않게 하려면 프로퍼티 단위로 복사 JSON 함수 활용 Deep Copyt","fields":{"slug":"/study-js-es6-object-3/"},"frontmatter":{"categories":"JS","title":"오브젝트 복사 - deep copy","date":"September 24, 2021"}},"next":{"fields":{"slug":"/study-js-es6-object-2/"}},"previous":{"fields":{"slug":"/study-js-es6-object-4/"}}},{"node":{"id":"7b51cc94-9497-55f7-87d3-41af468fb69c","excerpt":"1. assgin() 두 번째 파라미터의 오브젝트 프로터피를 첫 번째 파라미터의 오브젝트에 복사하고 첫 번째를 반환 만 복사 2. 첫 번째 파라미터 작성 첫 번째 파라미터를 작성하지 않거나 , 를 작성하면  , , ,  값 작성 첫 번째 파라미터에  를 작성하고 두 번째 파라미터를 작성하지 않음  인스턴스를 생성하여 파라미터 값 100을 에 설정 함 생성한 인스턴스를 반환함 , , 도 같은 방법으로 처리 3. 두 번째 파라미터 작성 열러 가능 오브젝트 작성 오브젝트 다수 작성 값을 작성 값과 오브젝트를 작성 값이 설정된 인스턴스 형태 1. assgin() 2. 첫 번째 파라미터 작성 3. 두 번째 파라미터 작성","fields":{"slug":"/study-js-es6-object-2/"},"frontmatter":{"categories":"JS","title":"오브젝트 복사 - assign()","date":"September 23, 2021"}},"next":{"fields":{"slug":"/study-js-es6-object-1/"}},"previous":{"fields":{"slug":"/study-js-es6-object-3/"}}},{"node":{"id":"cd6fb807-d015-52b4-91d4-cb92b099dc81","excerpt":"is() 두 개의 파라미터 값과 값 타입을 비교 같으면 , 아니면  오브젝트 비교 목적이 아님 와  비교, 와 비교는  JS 값 비교 방법 값과 타입까지 모두 비교:  타입은 비교하지 않고 값만 비교:  와  비교 차이 NaN 비교 +0과 -0 비교 활용한 형태 is()","fields":{"slug":"/study-js-es6-object-1/"},"frontmatter":{"categories":"JS","title":"is() - JS 값 비교","date":"September 22, 2021"}},"next":{"fields":{"slug":"/study-js-es6-string-4/"}},"previous":{"fields":{"slug":"/study-js-es6-object-2/"}}},{"node":{"id":"7231d0bf-cab6-56e3-bd4b-d97fef218934","excerpt":"1. padStart() 첫 번째 파라미터 값 만큼 길이를 늘리고 늘어난 끝에 대상 문자열을 설정한 후 앞의 남은 공간에 두 번째 파라미터를 채움 두 번째 파라미터에 채울 문자열 작성  10자리로 늘리고 8/9/10 번째에 “ABC”를 설정, 남은 7자리에 “123”을 왼쪽부터 반복하여 채움  6자리 끝에 ABC를 설정하면 3자리가 남음, 123456을 왼쪽부터 채우고 123이 채워짐  전체 길이가 대상 문자열보다 작으면 길이를 줄이지 않고 대상 문자열을 반환  두 번째 파라미터를 작성하지 않으면 남은 앞에 빈문자열을 채움 2. padEnd() 첫 번째 파라미터 값 만큼 길이를 늘리고 늘어난 끝에 대상 문자열을 설정한 후 뒤의 남은 공간에 두 번째 파라미터를 채움 두 번째 파라미터에 채울 문자열 작성  10자리로 늘리고 1/2/3 번째에 “ABC”를 설정, 남은 7자리에 “123”을 왼쪽부터 반복하여 채움  6자리 앞자리에 ABC를 설정하면 3자리가 남음, 123456을 왼쪽부터 …","fields":{"slug":"/study-js-es6-string-4/"},"frontmatter":{"categories":"JS","title":"길이 늘리기, 공백 삭제","date":"September 21, 2021"}},"next":{"fields":{"slug":"/study-js-es6-string-3/"}},"previous":{"fields":{"slug":"/study-js-es6-object-1/"}}},{"node":{"id":"48eaeab3-4bbd-5784-b35e-d6f157ff2269","excerpt":"1. startsWith() 대상 문자열이 첫 번째 파라미터의 문자열로 시작하면 , 아니면  반환 정규 표현식 사용 불가 두 번째 파라미터 선택이며, 비교 시작 인덱스 작성 2. endsWith() 대상 문자열이 첫 번째 파라미터의 문자열로 끝면 , 아니면  반환 두 번째 파라미터 선택이며, 사용할 문자열 길이 지정 3.repeat() 대상 문자열을 파라미터에 작성한 수 만큼 복제, 연결하여 반환 4. includes() 대상 문자열에 첫 번째 파라미터의 문자열이 있으면  없으면  반환 두 번째 파라미터(선택) 비교 시작 인덱스 작성 1. startsWith() 2. endsWith() 3.repeat() 4. includes()","fields":{"slug":"/study-js-es6-string-3/"},"frontmatter":{"categories":"JS","title":"시작/끝 체크 복제","date":"September 20, 2021"}},"next":{"fields":{"slug":"/study-js-es6-string-2/"}},"previous":{"fields":{"slug":"/study-js-es6-string-4/"}}},{"node":{"id":"e3bdb6c6-f385-5734-b51e-53dffd7f0dba","excerpt":"1. fromCodePoint() 유니코드의 코드 포인트에 해당하는 문자 반환 파라미터에 다수의 코드 포인트 작성 가능 문자를 연결하여 반환 ES5의 사용 로 작성 2. codePointAt() 대상 문자열에서 파라미터에 작성한 인덱스 번째 문자를 유니코드 코드 포인트로 변환하여 반환 코드 포인트는 UTF-16으로 인코딩된 값 3. normalize() 대상 문자열을 파라미터에 지정한 유니코드 정규화 형식으로 반환하여 반환 1. fromCodePoint() 2. codePointAt()","fields":{"slug":"/study-js-es6-string-2/"},"frontmatter":{"categories":"JS","title":"Unicode 함수","date":"September 19, 2021"}},"next":{"fields":{"slug":"/study-js-es6-string-1/"}},"previous":{"fields":{"slug":"/study-js-es6-string-3/"}}},{"node":{"id":"8e6facff-31ea-5f4d-a17a-124760627a2e","excerpt":"1. Unicode 유니코드는 U+0031 형태 코드 포인트 이 코드 포인트 문자 코드라고도 부름 코드 포인트로  등을 표현 4자리 이상의 UTF-16진수 형태 110만개 정도 표현 U+0000 ~ U+10FFFF Plane(평면) 코드 포인트 전체를 17개 plane으로 나눔 하나의 plane은 65535(U+FFFF)개 첫 번째 Plane BMP(Basic Multillingual Plane) 라고 부름 일반적인 문자(연문자, 숫자)가 여기에 속함 한글의 코드 포인트도 여기에 속함 첫 번째 Plane을 제외한 Plane Supplementary Plane, Astral Plane이라고 부름 5자리 이상의 코드 포인트를 표현할 수 있음 ES6+에서 지원 이스케이프 시퀀스(Escape Sequence) 역슬래시와 16진수로 값을 작성 이를 16진수 이스케이프 시퀀스라고 부름 유니코드 이스케이프 시퀀스 Unficode Escape Sequence 이스케이프 시퀀스를 유니코드로 작성한…","fields":{"slug":"/study-js-es6-string-1/"},"frontmatter":{"categories":"JS","title":"Unicode, ES5 호환성","date":"September 18, 2021"}},"next":{"fields":{"slug":"/study-js-es6-number-Object-3/"}},"previous":{"fields":{"slug":"/study-js-es6-string-2/"}}},{"node":{"id":"9468e300-596a-5194-852f-9f5d06672ea5","excerpt":"1. isNaN()  값의 여부를 체크  값이면 , 아니면  반환 글로벌 오브젝트의  값 타입이 가 아닌 것을 체크 함, 가  타입이므로  반환 와  은 값이 이므로 가 됨  값이 가 아니므로 가 됨 글로벌 오브젝트의  값을 숫자로 변환하고 그 결과로 비교 함, 변환한 값 이  이므로  반환 NaN 체크 방법  결과가 이므로 사용 불가 , 글로벌 오브젝트   :  2. isInteger() 파라미터 값이 이면 , 아니면  반환 정수로 인식 정수가 아닌 것으로 인식 값을 로 변환하여 체크하지 않음 r로 변환하면, 와 가 이므로 정수로 인식됨 3. isSafeInteger() 파라미터 값이 이면  아니면  반환  ~  :  아니면  4. isFinite() 파라미터 값이 유한 값이면  아니면  글로벌 오브젝트의 와 체크 결과가 다름 함수는 오브젝트에 속해야 하므로 와 관련된 것은  오브젝트의 함수 사용, 글로벌 오브젝트의 함수는 글로벌 사용이 목적 1. isNaN() 2. isInte…","fields":{"slug":"/study-js-es6-number-Object-3/"},"frontmatter":{"categories":"JS","title":"Number 함수","date":"September 17, 2021"}},"next":{"fields":{"slug":"/study-js-es6-number-Object-2/"}},"previous":{"fields":{"slug":"/study-js-es6-string-1/"}}},{"node":{"id":"c1c0eb43-f8ba-5d40-8eca-1b5b2be504a3","excerpt":"1. Number.EPSLON  아주 작은 값 2.220446049250313080847263361816E-16 또는 2^-52 사용 사례 미세한 값 차이 형태 JS가 부동소수점 처리를 하기 때문(IEEE 74) 이처럼 미세한 값 차이로 일치하지 않을 때 을 사용 미세한 값 차이를 같은 값으로 간주 값 차이가 보다 작으면 를 반환` 으로 가 되는 것을 방지  처럼 작은 값을 더해 나누면 이 됨 2. 진수 Binary(2진수) ,  형태로 작성 숫자  다음에  작성하고 이어서  또는 로 값을 작성 Octal(8진수)  형태로 작성 숫자  다음에 영문  작성하고 이어서 로 값을 작성 ES3는 첫 자리에 영문  작성 1. Number.EPSLON 2. 진수","fields":{"slug":"/study-js-es6-number-Object-2/"},"frontmatter":{"categories":"JS","title":"진수, EPSILON","date":"September 16, 2021"}},"next":{"fields":{"slug":"/study-js-es6-number-Object-1/"}},"previous":{"fields":{"slug":"/study-js-es6-number-Object-3/"}}},{"node":{"id":"ae2efbf2-370f-523a-a55c-9cda88814db9","excerpt":"1. IEEE 754 IEEE (Institute of Electrical and Electronics Engineers) JS는 IEEE 754에 정의된 64비트 부동 소수점으로 수를 처리 double-precision floating-point format numbers 64비트로 최솟값과 최댓값을 처리 정수와 실수를 구분하지 않음 1을 1.0으로 처리 1과 1.2를 더할 수 있음 2. 64비트 구성 사인 비트 63: 1비트 값이 0이면 양수, 1이면 음수 지수 52 ~ 62 : 11비트 가수 0 ~51 : 52비트 + 1(사인 비트): 53비트 3. 값을 구하는 방법 비트 값은  아니면  2^x승 값을 더해 값을 구함 0비트 부터 1, 1, 1이면 1(2^0) + 2(2^1) + 4 = 7 4. Number 상수 란 지수(e)를 사용하지 않고 나타낼 수 있는 값 2의 64승이 아닌 2의 53승  : safe integer 최댓값  : safe integer 최솟값 1. IEE…","fields":{"slug":"/study-js-es6-number-Object-1/"},"frontmatter":{"categories":"JS","title":"IEEE 754, 64비트 구성, 값을 구하는 방법, Number 상수","date":"September 15, 2021"}},"next":{"fields":{"slug":"/study-js-es6-getter-setter/"}},"previous":{"fields":{"slug":"/study-js-es6-number-Object-2/"}}},{"node":{"id":"b13e80d0-ae7d-5799-a10d-894abb6151ff","excerpt":"1. Getter 로 선언된 함수를 자동으로 호출 값을 반환하는 시맨틱을 갖고 있으므로  함수에서 값을 반환해야 함 ES5 형태 을 실행하면  프로퍼티에서  속성의 존재를 체크 함 있으면,  함수를 호출하며 이 반환되어 출력 됨  처럼 함수로 호출하면 에러가 발생함 ES5의 를 참조하세요 ES6 형태  처럼  앞에 을 작성하면 로 선언됨  함수가 자동으로 호출 됨 ES6 장점 ES5처럼 프로퍼티의 속성 구조가 아님 작성 편리 다수의  사용 가능 2. Setter 프로퍼티에 값을 할당하면 로 선언된 함수 자동 호출 값을 설정하는 시맨틱을 갖고 있으므로  함수에서 값을 설정해야 함 ES5 형태 를 실행하면  프로퍼티에  속성의 존재 여부를 체크 있으면,  함수를 호출 를 파라미터 값으로 넘겨 줌 ES6 형태 ) 앞에 을 작성하면 로 선언됨  에 값을 할당하면 가 자동으로 호출 됨 파라미터 값으로 을 넘겨줌 변숫값을 함수 이름으로 사용  변숫값인 “setPoint”가 함수 이름으로 사용…","fields":{"slug":"/study-js-es6-getter-setter/"},"frontmatter":{"categories":"JS","title":"Getter, Setter","date":"September 14, 2021"}},"next":{"fields":{"slug":"/study-js-es6-operator/"}},"previous":{"fields":{"slug":"/study-js-es6-number-Object-1/"}}},{"node":{"id":"da30f078-9791-5b6a-817a-228fe27e8cb1","excerpt":"1. Trailing Commas 배열 끝에 콤바 사용 가능  앞에 콤마 사용 가능  끝에 콤바 사용  앞에 콤마 사용 가능 2. 거듭 제곱 좌결 합성 왼쪽에서 오른쪽으로 계산 은 으로 계산 우결 합성(거듭제곱 계산 할 때만) 오른쪽에서 왼쪽으로 계산 에서 로 계산 은 2의 3승의 2승이 아니라 먼저 3의 2승을 구하며(9) 2의 9승으로 512가 됨 2. Try-Catch 의 에서 처럼 (error)를 생략 가능 ES2019 에서 메시지를 받아 사용하지 않을 때 편리 함 타이핑 실수를 방지 할 수 있음 3. 함수 작성 형태 에 함수를 작성할 때  키워드를 작성하지 않아도됨 참고 : 에 함수를 작성하는 이유 함수에서 로  전체 참조  연산자로 인스턴스를 생성하지 않음, 메소드가 아닌 함수로 접근  전체가 하나의 묶음 접근성, 가독성이 좋음 에 시맨틱을 부여할 수 있으며 다른 오브젝트와 이름과 프로퍼티 이름이 충돌되지 않음 처럼  키워드를 사용하지 않음 1. Trailing Comm…","fields":{"slug":"/study-js-es6-operator/"},"frontmatter":{"categories":"JS","title":"Operator","date":"September 13, 2021"}},"next":{"fields":{"slug":"/study-js-es6-for-in/"}},"previous":{"fields":{"slug":"/study-js-es6-getter-setter/"}}},{"node":{"id":"94db4223-afa1-5805-8eb0-09ae8e13c3fc","excerpt":"1. For-Of  이터러블 오브젝트를 반복 Iterable 이터러블 오브젝트를 작성 표현식을 작성하면 평가 결과를 사용 Variable 변수 이름 작성 이터러블 오브젝트를 반복할 때마다 Variable에 값이 할당됨 배열 배열을 반복하면서 엘리먼트를 하나씩 전개 String 문자열을 반복하면서 문자를 하나씩 전개 NodeList NodeList를 반복하면서 엘리먼트를 하나씩 전개 2. For-in, For-of의 차이 for-in 열거 가능한 프로퍼티가 대상  형태는 디폴트가  는 디폴트가  for-of 이터러블 오브젝트가 대상 Object는 전개되지 않음 Property의 프로퍼티도 전개되지 않음 3. for-of, Object Object는 이터러블 오브젝트가 아니므로 for-of 사용 불가 Object를 로 전개할 수 있는 방법 로 프로퍼티 이름을 배열로 만들고 만든 배열을 로 전개 1. For-Of 2. For-in, For-of의 차이 3. for-of, Object","fields":{"slug":"/study-js-es6-for-in/"},"frontmatter":{"categories":"JS","title":"for-of, for-in for-of 차이, for-of Object","date":"September 12, 2021"}},"next":{"fields":{"slug":"/study-js-es6-default-value/"}},"previous":{"fields":{"slug":"/study-js-es6-operator/"}}},{"node":{"id":"9ded2c69-1cdb-5980-8887-26f15144405d","excerpt":"Default Value 값을 할당하지 않으면 사전에 정의된 값을 할당 default value : 사전에 정의된 값 할당할 값이 없으면 디폴트 값을 할당 에 10을, 에 20을 분할 할당 함 에 할당할 값이 없으며, 이 때 에서 을 에 할당함 이것을 라고 함 의 왼쪽에 이름을 작성하고 오른쪽에 값을 작성 할당할 값이 있으면 디폴트 값을 무시 왼쪽과 오른쪽 모두 값이 3개 임 값(70)이 있으므로 에 을 할당함 에서 을 할당하지 않음 Object는 프로퍼티 이름으로 체크 오른쪽에 의 값인 을 왼쪽의  프로퍼티 값으로 분할 할당함 에 할당할 값이 없으며 에서 을 에 할당 함 디폴트 값 적용 순서 왼쪽에서 오른쪽으로 적용 오른쪽 one의 값인 10을 왼쪽의 one 프로퍼티 값으로 분할 할당함 오른쪽에 값이 없으므로 디폴트 값을 할당, 왼쪽에서 오른쪽으로 할당 , one의 값이 10이므로 30이 two에 설정됨 , two의 값이 30이므로 80이 five에 설정됨 함수의 파라미터에 디폴…","fields":{"slug":"/study-js-es6-default-value/"},"frontmatter":{"categories":"JS","title":"Default Value","date":"September 11, 2021"}},"next":{"fields":{"slug":"/study-js-es6-destructuring-3/"}},"previous":{"fields":{"slug":"/study-js-es6-for-in/"}}},{"node":{"id":"fad1e791-efc3-5be8-915b-c114b47739c6","excerpt":"1. Object 오퍼레이션 같은 프로퍼티 이름 사용 에서 프로퍼티 이름인 이 같음  모드에서 프로퍼티 이름이 같으면 에러 뜸 에서는  모드에 관계없이 에러가 발생하지 않음, 뒤에 작성한 프로퍼티 값으로 대체됨 Shorhand property names 과  변수에 값을 작성하였으며  형태로 에 할당함 이 프로퍼티 이름이 되고 이 프로퍼티 값으로 할당됨 은 MDN에 작성된 것으로 스펙에 정의된 것은 아님 2. 프로퍼티 이름 조합 문자열을 프로퍼티 이름으로 사용 과 를 연결하여 를 프로퍼티 이름으로 사용 함 변숫값을 프로퍼티 이름으로 사용 변숫값을 프로퍼티 이름으로 사용 함 변숫값과 문자열을 연결할 수 있음 프로퍼티 이름에 공백이 있는 것이 어색하지만 공백을 넣을 수 있음 함수로 호출 할 수 있음, 변숫값에 따라 함수 이름을 정의 할 수 있음 분할 할당을 조합한 형태 변숫값을 프로퍼티 이름으로 사용하고 분할 할당한 형태 이  형태가 됨 이 에 “책”이 할당됨 1. Object 오퍼레…","fields":{"slug":"/study-js-es6-destructuring-3/"},"frontmatter":{"categories":"JS","title":"Object 오퍼레이션, 프로퍼티 이름 조합","date":"September 10, 2021"}},"next":{"fields":{"slug":"/study-js-es6-destructuring-2/"}},"previous":{"fields":{"slug":"/study-js-es6-default-value/"}}},{"node":{"id":"d427dfee-9c58-5b5d-a6c4-040dede7c3a8","excerpt":"1. Object 분할 할당 의 프로퍼티를 분할하여 할당 프로퍼티 이름이 같은 프로퍼티에 값을 할당 왼쪽의 가  형태가 아니라 프로퍼티 이름만 작성함 프로퍼티 이름이 같은 오른쪽 프로퍼티 값을 왼쪽의 프로퍼티 값으로 할당 에 , 에 을 할당,  형태가 됨 프로퍼티 이름을 별도로 작성  프로퍼티 이름을 앞에 별도로 작성함  전체를 소괄호() 안에 작성해야 함 프로퍼티 값 위치에 변수 이름 작성 이름을 별도로 선언하였으므로 소괄호() 안에 작성했음 오른쪽  프로퍼티 값 5를 five에 할당 오른쪽  프로퍼티 값 6을 six에 할당  을 실행하면  프로퍼티 이름으로 값을 구할 수 없음 와  변숫값을 구하는 것이 목적 Object 구조에 맞추어 값 할당  plus는 구조(경로)를 만들기 위한 것 왼쪽에 가 있고 가 있으면  프로퍼티 값에 을 할당함 구조가 같지 않으면 실행할 때 에러 발생  는 구조(경로)를 만들기 위한 것으로 실제로 존재하지 않음 가 없으므로  발생 할당한 후, 이름으로…","fields":{"slug":"/study-js-es6-destructuring-2/"},"frontmatter":{"categories":"JS","title":"Object 분할 할당, 파라미터 분할 할당","date":"September 09, 2021"}},"next":{"fields":{"slug":"/study-js-es6-destructuring-1/"}},"previous":{"fields":{"slug":"/study-js-es6-destructuring-3/"}}},{"node":{"id":"749ce0e7-bf5b-5e62-93d5-7b6348b35b49","excerpt":"1. Destructuring Destructuring Assignment 사전적 의미 ~구조를 파괴하다. 파괴, 해체는 있는 것이 없어지는 뉘앙스 원 데이터는 변경되지 않음 이 관점에서 보면 분할/분리가 더 까움 2. Array 분할 할당 배열의 엘리먼트를 분할하여 할당(인덱스에 해당하는 변수에 할당) 할당 받을 변수 수가 적은 경우 왼쪽에 할당 받을 변수가 2개이고, 오른쪽에 분할 할당할 값이 3개 임 왼쪽의 변수 인덱스에 맞추어 값을 할당하므로 3은 할당되지 않음 할당 받을 변수 수가 많을 경우 왼쪽의 할당 받을 변수가 4개이고 오른쪽에 분할 할당할 값이 3개 임 왼쪽에 값을 할당할 수 없는 변수에 가 설정됨 배열 차원에 맞추어 분할 할당 매치되는 인덱스에 변수가 없으면 값을 할당하지 않음 Spread와 같이 사용 나머지를 전부 할당 에 1을 할당하고 나머지 2, 3, 4를 에 할당 함, 처럼 배열로 할당함  파라미터를 호출 받는 함수의 파라미터에 작성하지만, 나머지라는 시맨…","fields":{"slug":"/study-js-es6-destructuring-1/"},"frontmatter":{"categories":"JS","title":"Destructuring, Array 분할 할당","date":"September 08, 2021"}},"next":{"fields":{"slug":"/study-js-es6-spread-2/"}},"previous":{"fields":{"slug":"/study-js-es6-destructuring-2/"}}},{"node":{"id":"a4852f34-5b20-599f-be85-bda0b982bea3","excerpt":"1. Function Spread 호출하는 함수의 파라미터에  대상 작성 처리 순서 및 방법 함수가 호출되면 우선, 파라미터의 배열을 엘리먼트 단위로 전개 전개한 순서대로 파라미터 값으로 넘겨 줌 호출 받는 함수의 파라미터에 순서대로 매핑됨 , , 이 매핑 됨 2. Rest 파라미터 Syntax:  분리하여 받은 파라미터를 배열로 결합  : 분리, : 결합 작성 방법 호출받은 함수의 파라미터에 에 이어서 파라미터 이름 작성 호출한 함수에서 보낸 순서로 매핑 , , 이 매핑 됨 파라미터와  파라미터 혼합 사용 에 10이 설정되고 설정되지 않은 나머지 값 전체가 파라미터 에 설정됨 그래서  파라미터 임 나머지라는 시맨틱을 나타내기 위해 파라미터 이름을 로 사용하기도 함 3. Array-like  타입이지만 배열처럼 이터러블 가능한 오브젝트 문으로 전개할 수 있음 작성 방법 프로퍼티  값을 0부터 1씩 증가하면서 프로퍼티 값을 작성 에 전체 프로퍼티 수 작성 이렇게 작성하지 않으면 그냥…","fields":{"slug":"/study-js-es6-spread-2/"},"frontmatter":{"categories":"JS","title":"Rest 파라미터","date":"September 07, 2021"}},"next":{"fields":{"slug":"/study-js-es6-spread-1/"}},"previous":{"fields":{"slug":"/study-js-es6-destructuring-1/"}}},{"node":{"id":"a90ba1f2-8d81-58a0-a9cd-34bdf250d295","excerpt":"1. let, const 사용 기준  : 변경 할 수 있음  : 변경 할 수 없음 ,  변수의 시맨틱을 우선하여 사용 값이 변경되면  초깃값이 변경되지 않으면  2. Spread Syntax:   처럼   안에 점 3개를 작성하고 이어서 이터러블 오브젝트 작성 이터러블 오브젝트를 하나씩 전개 의 가 이터러블 오브젝트는 아니지만 전개 가능 3. Array Speard  대상 배열을 작성한 위치에 엘리머트 단위로 분리(전개)  작성 형태  :  배열의 를 엘리먼트 단위로 분리(전개) 함  :  위치에  배열의 를 엘리먼트 단위로 분리(전개) 함 값이 대체되지 않고 전개 앞에 과 가 있지만 값을 대체하지 않고 을 작성한 위치에 전개 함 4. String Spread  대상 문자열을 작성한 위치에 문자 단위로 전개  작성 형태  의 를 문자 단위로 분리하여  위치에 설정 5. Object Spread  대상 를 작성한 위치에 프로퍼티 단위로 전개  작성 형태  :  오브젝트의 프로퍼티를 …","fields":{"slug":"/study-js-es6-spread-1/"},"frontmatter":{"categories":"JS","title":"Spread(스프레드)","date":"September 06, 2021"}},"next":{"fields":{"slug":"/study-js-es6-iteration-3/"}},"previous":{"fields":{"slug":"/study-js-es6-spread-2/"}}},{"node":{"id":"7d74bd95-26f7-5b37-b048-ddd398c19d8b","excerpt":"1. 이터레이터 프로토콜 이터레이터(iterator) 프로토콜 값을 순서대로 생성하는 방법(규약) 이터레이터 오브젝트 를 호출하면 이터레이터 오브젝트를 생성하여 반환 이터레이터 오브젝트에 가 있음 생성한 오브젝트를 이터레이터라고 부름 이터레이터 오브젝트의 를 호출하면 이터레이터를 호출한다고도 함  를 반환함, 에서 첫 번째 값이고 는 이터레이터 상태 임 두 번째  호출  를 반환함, 에서 두 번째 값이고 는 이터레이터 상태 임 세 번째  호출  반환, 는 처리할 값이 없다는 것을 뜻하며 는 이터레이터의 종료를 뜻함 이터레이터 오브젝트 구조 1. 이터레이터 프로토콜","fields":{"slug":"/study-js-es6-iteration-3/"},"frontmatter":{"categories":"JS","title":"이터레이터 오브젝트, 프로토콜","date":"September 05, 2021"}},"next":{"fields":{"slug":"/study-js-es6-iteration-2/"}},"previous":{"fields":{"slug":"/study-js-es6-spread-1/"}}},{"node":{"id":"609a2e9f-c47d-572e-8ae7-7af1c8a30c16","excerpt":"1. 이터러블 오브젝트 1). 이러터블 오브젝트 개념 이터러블 프로토콜을 갖고 있는 오브젝트 스펙에서는 로 표기 반복 구조,   리터럴로 생성한 에 가 있으므로 는 이터러블 오브젝트 임  리터럴로 생성한 에 가 없으므로 는 이터러블 오브젝트가 아님  문의 반복과 이터레이션이 차이가 있듯이, 의 열거와 이터레이션은 차이가 있음 2). 이터러블 오브젝트 구조 3). 자체 오브젝트에는 없지만 이터러블 오브젝트를 상속받아도 됨 즉, 에 있으면 됨 예를 들어,  오브젝트를 상속 받으면 이터러블 오브젝트가 됨 2. 이터러블 프로토콜 1). 이터러블 프로토콜 개념 오브젝트가 반복할 수 있는 구조이어야 함 를 갖고 있어야 함 2). 아래 빌트인 오브젝트는 디폴트로 이터러블 프로토콜을 갖고 있음 즉 를 갖고 있음 -, , , , , ,  1. 이터러블 오브젝트 1). 이러터블 오브젝트 개념 2). 이터러블 오브젝트 구조 3). 자체 오브젝트에는 없지만 2. 이터러블 프로토콜 1). 이터러블 프로토…","fields":{"slug":"/study-js-es6-iteration-2/"},"frontmatter":{"categories":"JS","title":"이터러블 오브젝트, 프로토콜","date":"September 04, 2021"}},"next":{"fields":{"slug":"/study-js-es6-iteration-1/"}},"previous":{"fields":{"slug":"/study-js-es6-iteration-3/"}}},{"node":{"id":"58fc7cd7-afb8-5d42-b489-17fd89c6bb54","excerpt":"1. 이터레이션 이터레이션(Iteration)의 사전적 의미 : 반복 문의 반복 개념과 차이 있음 이터레이션을 위한 프로토콜(Protocol) 필요 예: 통신 프로토콜(규약) 데이터 송수신 프로토콜 정의 어떻게 반복을 할 것인가에 대한 규약이 필요 즉, 이터레이션은 프로토콜을 갖고 있으며 프로토콜에 따라 이터레이션 수행 프로토콜이 구문과 빌트인이 아니므로 프로토콜에 맞으면 이터레이션 가능 2. 이터레이션 프로토콜 이터레이션 프로토콜(규약)은 오브젝트가 이터레이션 할 수 있는 구조이어야 하며 10, 20은 가능, 100은 불가능 이터레이션 프로토콜 구분 이터러블(iterable) 프로토콜 : 반복가능 한 것 이터레이터(iterator) 프로토콜 :  처럼 반복문을 실행시키는 것\n—> 이렇게 이터러블, 이터레이터를 규약하는 이유는?  때문에 개발자 코드로 프로토콜을 맞추면 이터레이션 할 수 없는 오브젝트를 이터레이션 할 수 있도록 만들 수 있음 1. 이터레이션 2. 이터레이션 프로토콜","fields":{"slug":"/study-js-es6-iteration-1/"},"frontmatter":{"categories":"JS","title":"이터레이션","date":"September 03, 2021"}},"next":{"fields":{"slug":"/study-js-es6-arrowFunction-4/"}},"previous":{"fields":{"slug":"/study-js-es6-iteration-2/"}}},{"node":{"id":"944938f0-3cf5-510c-87f6-813ce60b8755","excerpt":"1. 화살표 함수와 인스턴스 인스턴스에서 화살표 함수의 에 따라 가 참조하는 오브젝트가 다름 1). 에 메소드로 작성 에 화살표 함수를 연결하면 함수 안에서 가 글로벌 오브젝트를 참조 함  에서 글로벌 오브젝트의  값이 200을 출력 2). 의 메소드 안에 작성 에 일반 함수를 연결하고, 함수 안에 화살표 함수를 작성한 형태 임. 가 일반 함수 이므로 가 생성한 인스턴스 참조 또한, 화살표 함수에서도 가 생성한 인스턴스를 참조 함 화살표 함수의 스코프인 의 를 사용하기 때문 2. 화살표 함수 특징  대신  를 사용, 함수 표현식 형태 이 없으므로 함수가 가벼움 가 없으므로  연산자로 인스턴스를 생성할 수 없음 화살표 함수에 가 없음 화살표 함수로  오브젝트를 생성할 때 정적으로 화살표 함수가 속한 스코프의 를 화살표 함수에 바인딩 함 바인딩 된  참조가 바뀌지 않으며 화살표 함수에서 로 사용 함 일반 함수는  등으로 바꿀 수 있음 메소드보다 함수로 사용하는 것이 효율 성이 높음 1…","fields":{"slug":"/study-js-es6-arrowFunction-4/"},"frontmatter":{"categories":"JS","title":"Arrow Function과 인스턴스","date":"September 02, 2021"}},"next":{"fields":{"slug":"/study-js-es6-arrowFunction-2/"}},"previous":{"fields":{"slug":"/study-js-es6-iteration-1/"}}},{"node":{"id":"fe8e3dc1-fa36-5877-b540-31d36e24463a","excerpt":"1) 화살표 함수 구조 을  로 표기하는 것이 전부가 아님 화살표 함수는 일반 함수와 구조가 다름 화살표 함수 나름의 특징이 있음 2) Arguments 사용 불가 (파라미터가 유동적일 때 사용하는 것) 사용 할 수 없음  대신에  파라미터 사용 1) 화살표 함수 구조 2) Arguments 사용 불가","fields":{"slug":"/study-js-es6-arrowFunction-2/"},"frontmatter":{"categories":"JS","title":"Arrow Function 구조","date":"September 02, 2021"}},"next":{"fields":{"slug":"/study-js-es6-arrowFunction-3/"}},"previous":{"fields":{"slug":"/study-js-es6-arrowFunction-4/"}}},{"node":{"id":"2c97ba6c-5326-5120-bf8f-14b9559810fa","excerpt":"1. 화살표 함수와 this 1).  모드에서 함수를 호출할 때 함수 앞에 오브젝트 작성은 필수  모드에서는  처럼 호출하는 함수 앞에 오브젝트를 작성해야 함, 이렇게 하지 않으면  함수 안에서  값이  또한,  처럼 를 앞에 작성하지 않으면  안에서  값이  임 이를 피하기 위해 로 호출하면  오브젝트에 가 없으므로 에러가 남(현재  함수 블록 안에 가 있음)  모드의 함수에서 를 참조하기 위해서는 를 별도로 저장한 후 사용해야 하는 번거로움이 있음 —> 화살표 함수로 해결 가능 2). 화살표 함수에서 가 글로벌 오브젝트 참조 화살표 함수로 작성하면 로 호출할 수 있음 또한,  화살표 함수 안에서 가 가 아니라 글로벌() 오브젝트를 참조 함 을 작성했으므로 100이 출력됨 3). 값이  2. 가 정적 스코프 참조 화살표 함수에서 정적 스코프의 를 사용 정적(Lexical)스코프란 엔진이 해석할 때, 화살표 함수를 만나면 를 생성하고 화살표 함수가 속한 스코프를 생성한 함수 오브젝…","fields":{"slug":"/study-js-es6-arrowFunction-3/"},"frontmatter":{"categories":"JS","title":"Arrow Function와 this","date":"September 02, 2021"}},"next":{"fields":{"slug":"/study-js-es6-arrowFunction-1/"}},"previous":{"fields":{"slug":"/study-js-es6-arrowFunction-2/"}}},{"node":{"id":"6e3f296c-2cc8-51d1-a8c0-2ae50571cf35","excerpt":"1) Arrow Function 의 사전적 의미 : 화살, 화살표 코드 형태   키워드 대신에 화살표  사용 표 양쪽에 공백 작성 가능 의 축약 형태이지만, 고려할 사항도 있음( 참조가 다름) 2) 함수 블록 사용 함수 블록과  작성생략 함수 블록과 을 생략한 형태로 와 같음  앞에서 줄을 분리하면   뒤에서는 개행 가능 함수 블록 만 작성한 형태 함수 블록만 작성하면  반환 함수 블록에 을 작성하지 않은 것과 같음 을 작성하지 않으면 로 를 반환 함 화살표가 함수이기 때문이 아니라  문법임 를 반환하는 형태 를 소괄호()로 감싸면 를 반환함 소괄호()을 작성하지 않으면 를 반환함 3) 파라미터 사용 파라미터가 하나 일 때 파라미터가 하나이면 에서 소괄호를 생략할 수 있음 에서 이 에 설정됨 파라미터가 없으면 소괄호만 작성 파라미터가 없으면 소괄호만 작성할 수 있음 1) Arrow Function 2) 함수 블록 사용 3) 파라미터 사용","fields":{"slug":"/study-js-es6-arrowFunction-1/"},"frontmatter":{"categories":"JS","title":"Arrow Function 사용","date":"September 02, 2021"}},"next":{"fields":{"slug":"/study-js-es6-letVSvar/"}},"previous":{"fields":{"slug":"/study-js-es6-arrowFunction-3/"}}},{"node":{"id":"446e2c83-a4ef-5bf3-93b1-2e5e42cef9b6","excerpt":"💡 요약 문에서 반복 할 때마다  변수는 스코프를 갖지 않음  변수는 스코프를 가짐 1) var 변수와 스코프 어떤 것을 클릭하더라도 항상 문이 끝났을 때의 값인 을 출력함 전체의 스코프에서 하나의 값으로 할당되기 때문 for문의 마지막 값인 이  선언된  즉 글로벌 변수에 할당 됨.  에서 k 변수의 스코프는 함수 임 2) let 변수와 스코프 이벤트를 설정할 때의 값을 출력 합니다. 💡 요약 1) var 변수와 스코프 2) let 변수와 스코프","fields":{"slug":"/study-js-es6-letVSvar/"},"frontmatter":{"categories":"JS","title":"let vs var","date":"September 01, 2021"}},"next":{"fields":{"slug":"/study-js-es6-letAndThis/"}},"previous":{"fields":{"slug":"/study-js-es6-arrowFunction-1/"}}},{"node":{"id":"db5e22a8-796d-50b8-9b79-2b2606f9d82f","excerpt":"1) 글로벌 오브젝트에서 let변수를 this로 참조 불가 현재 위치는 글로벌 오브젝트   오브젝트에 설정됨   오브젝트에 설정되지 않음 에서 가  오브젝트를 참조 하며 이  오브젝트에 설정되어 있으므로 “음악”이 출력됨 에서 sports가 에 설정되지 않으므로 가 출력됨 2) 엔진 관점에서 let 변수 처리   변수를 블록 안에 작성해야 하지만, 블록이 없으므로 엔진이 블록을 만들고 이를 스코프로 사용하여 설정함 위에 언급한 것 같이 현재 에  변수에 할당한 값이 존재 이것은 를 하나의 블록 개념으로 에 작성한 모든 파일에서 공유 가능 1) 글로벌 오브젝트에서 let변수를 this로 참조 불가 2) 엔진 관점에서 let 변수 처리","fields":{"slug":"/study-js-es6-letAndThis/"},"frontmatter":{"categories":"JS","title":"let and this","date":"September 01, 2021"}},"next":{"fields":{"slug":"/study-js-es6-let/"}},"previous":{"fields":{"slug":"/study-js-es6-letVSvar/"}}},{"node":{"id":"437a7b4b-db57-5b7e-935a-f7563b551f34","excerpt":"1) let 변수 개요  블록 스코프를 가진 변수 변수가 선언된 블록이 스코프 스코프 적용 기준 블록, 문, 표현시 블록 안과 밖이 스코프가 다름 변수 이름이 같아도 값이 대체되지 않음 2) let 변수 선언 Syntax  , 에 변수 이름 작성 식별자로 사용 는 생략 가능을 나타냄 값을 할당하지 않아도 됨  값을 할당하지 않고 변수만 선언할 수 있음, 초깃값 가 할당됨  콤마로 구분하여 다수를 선언할 수 있음 , 에 초깃값 작성 표현식 작성 가능, 평가 결과 사용  변수를 선언하고 초깃값을 할당했습니다.  콤마로 구분하여 다수의 변수를 선언하고 값을 할당한 형태임   발생, 을 처음에 한 번만 작성함  콤마로 구분하여 let과 var을 같이 사용할 수 없음 3) 블록 스코프 블록 기준 중괄호    블록 안과 밖이 스코프가 다름 변수 이름이 같아도 값이 대체되지 않음  블록  안과 밖에 를 작성했으며 스코프가 다르므로 같은 이름을 사용할 수 있음 변숫값이 대체되지 않고 유지 됨 블…","fields":{"slug":"/study-js-es6-let/"},"frontmatter":{"categories":"JS","title":"let 변수","date":"September 01, 2021"}},"next":{"fields":{"slug":"/study-js-es6-hoisting/"}},"previous":{"fields":{"slug":"/study-js-es6-letAndThis/"}}},{"node":{"id":"cef48574-1c60-5dcb-b5e8-d86b71431b7b","excerpt":"1) ES5의 실행 콘텍스트 처리 순서 함수 선언문 설정(함수부터 찾음) 변수 이름을 바인딩, 변숫 값은 (변수 이름 찾고 값은 라고 넣음) 소스 코드 실행 2) var 변수 호이스팅  코드 아래  이 존재 변수가 아래에 있지만 식별자 해결을 할 수 있음 단, 이 위에서  값은  이것을 이라고 함 식별자 해결을 하지 못하면 에러가 발생 3) let 변수 호이스팅 사용 불가  변수는 호이스팅되지 않음, 즉  변수 앞에서 변수 사용 불가  변수를 인식하는 시점  안에  변수 작성 1) ES5의 실행 콘텍스트 처리 순서 2) var 변수 호이스팅 3) let 변수 호이스팅 사용 불가","fields":{"slug":"/study-js-es6-hoisting/"},"frontmatter":{"categories":"JS","title":"호이스팅","date":"September 01, 2021"}},"next":{"fields":{"slug":"/study-js-es6-const/"}},"previous":{"fields":{"slug":"/study-js-es6-let/"}}},{"node":{"id":"822fafdf-3954-5f4c-8e70-f920531f0ce4","excerpt":"1) const 문법 구문:  값을 바꿀 수 없는 변수 선언(예외로 배열이나, 객체면 값을 바꿀 수 있음) 에 변수 이름 작성, 식별자로 사용  sports를 로 선언하고 값 할당  try 블록도 별도의 스코프이지만 const, let을 작성하지 않았으므로 sports 변수에 값을 할당하게 됨 이때 가  변수 이므로 에러 발생 2) JS에서 상수는 대문자 사용이 관례 가 이지만 값 형태에 따라 바꿀 수 있음  대문자 사용이 코딩 관례이므로 괜찮음 우선 이 아닌  사용 가능을 검토(우선순위  >  > ) 3) const 변수 사용  변수 전체를 바꿀 수 없지만, 의 프로퍼티 값을 바꿀수 있음  book에 값을 할당하면 에러 발생,  전체를 바꿀 수 없음  프로퍼티 값은 변경할 수 있음  변수의 변경 불가는 에 값을 할당하는 것을 뜻 함 의 엘리먼트 값도 바꿀 수 있음  book에 값을 할당하면 에러 발생  엘리먼트 값은 변경할 수 있음 1) const 문법 2) JS에서 상수는 대문…","fields":{"slug":"/study-js-es6-const/"},"frontmatter":{"categories":"JS","title":"const 변수","date":"September 01, 2021"}},"next":{"fields":{"slug":"/study-js-es6-declaration-position/"}},"previous":{"fields":{"slug":"/study-js-es6-hoisting/"}}},{"node":{"id":"0cd4ae9d-56cd-52c4-bf07-716ebd561996","excerpt":"💡 요약 모든  파일에서 글로벌 오브젝트에 작성한  변수와  변수를 공유  안에 작성하면 공유하지 않음 변수를 어디에 선언하냐에 따라 저장 위치가 다름 1) 글로벌 오브젝트에 작성  : , , , 에 변수가 저장됨  : 에 설정됨, 공유가능  : 에 설정됨, 공유가능 처럼 의도적으로 작성하지 않아도 됨  : 에 설정됨, 공유 불가능 글로벌 오브젝트에서만 사용하는 로컬 변수로 사용 2) 함수에 작성  : 에 설정됨  : 에 설정됨 💡 요약 1) 글로벌 오브젝트에 작성 2) 함수에 작성","fields":{"slug":"/study-js-es6-declaration-position/"},"frontmatter":{"categories":"JS","title":"변수 선언 위치","date":"September 01, 2021"}},"next":{"fields":{"slug":"/study-js-es6-scope/"}},"previous":{"fields":{"slug":"/study-js-es6-const/"}}},{"node":{"id":"eeaba52d-251a-5d14-b617-1315a6f5d494","excerpt":"1) function 블록 도 블록 스코프  안과 밖에 같은 이름의  변수 선언 가능 스코프가 다르기 때문 그래서 밖의 와 안의 는 다르게 저장되어 있음  밖의  변수를  안에서 사용 가능() 2) try-catch  문도 블록 스코프  블록  기준으로 안과 밖에 같은 이름의  변수 선언 가능  블록의 안과 밖에 를 선언했으며 안과 밖이 스코프가 다르므로 변숫값이 각각 설정됨 에서  밖의 변수 사용   블록에서 값을 할당   변수가 없으므로 에러가 발생   블록 안에서 선언한  값을 출력하지 않고  밖의  값을 출력 함 3) switch-case 문도 블록 스코프  블록 기준으로 같은 이름의  변수 작성 불가 , 는 블록 스코프가 아님   블록 안에서 을 사용하여 선언한 변수가 있는데 다시 을 사용하여 변수를 선언하므로 에러가 발생 그래서 주석으로 처리 에러는 실행할 때 생기지 않고 컴파일 할 때 에러가 발생함 1) function 블록 2) try-catch 3) switch-c…","fields":{"slug":"/study-js-es6-scope/"},"frontmatter":{"categories":"JS","title":"function 블록, try-catch, switch-case","date":"August 31, 2021"}},"next":{"fields":{"slug":"/study-js-es6-variable/"}},"previous":{"fields":{"slug":"/study-js-es6-declaration-position/"}}},{"node":{"id":"4183a7d4-57bf-5a35-9edc-682f612b03ef","excerpt":"1) 변수 구분 로컬(지역) 변수, 글로벌(전역) 변수 변수를 구분하는 이유는? 기능과 목적이 다르기 때문 글로벌 변수의 기능, 목적 다른 JS 파일에서 변숫값 공유 파일에서 공통 변수 개념으로 사용 의도는 좋으나 처리 속도가 떨어짐 로컬 변수의 기능, 목적 빠르게 식별자를 해결하기 위해 가까운 스코프(예를 들어 함수 스코프)의 변수를 사용하려는 것  키워드 문제 2) 글로벌 변수 오해 글로벌 변수는 글로벌 오브젝트의 로컬 변수 처럼 var 키워드 사용이 정상  키워드를 작성하지 않으면 글로벌 변수로 간주하는데 이것이 문제  키워드를 사용하지 않고 를 글로벌 변수로 선언하고 100에 할당  함수 안에서  변수(글로벌 변수)에 300 할당,  변수가 로컬 변수가 아님, 즉 글로벌 오브젝트의  변수에 300 할당 함수 안에서 글로벌 변수에 값을 설정하는 것은 좋은 것이 아님 로컬 변수와 글로벌 변수를 구분한 목적을 생각해야 함 예를 들어 함수 안에서 지역 변수를 선언해 사용하면 빠르게…","fields":{"slug":"/study-js-es6-variable/"},"frontmatter":{"categories":"JS","title":"let, const 변수","date":"August 30, 2021"}},"next":{"fields":{"slug":"/read-book-1/"}},"previous":{"fields":{"slug":"/study-js-es6-scope/"}}}]}},"staticQueryHashes":["1073350324","2938748437"]}