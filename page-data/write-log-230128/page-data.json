{"componentChunkName":"component---src-templates-blog-template-js","path":"/write-log-230128/","result":{"data":{"cur":{"id":"fde2e3f2-4010-5a7c-bedf-183ce14702fc","html":"<h1 id=\"️-배운-내용\" style=\"position:relative;\"><a href=\"#%EF%B8%8F-%EB%B0%B0%EC%9A%B4-%EB%82%B4%EC%9A%A9\" aria-label=\"️ 배운 내용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>✏️ 배운 내용</h1>\n<p>먼저 설날 연휴가 있다보니, 업무 보다는 개인 공부를 통해 배운 내용들을 적어본다.</p>\n<ol>\n<li>\n<p>Code Spliting</p>\n<ul>\n<li>SPA 번들 사이즈가 커지면, 로딩 속도나 성능면에서 문제가 생기기 때문에 이것들을 여러개의 번들로 나누거나 동적으로 import 하는 기법</li>\n</ul>\n</li>\n<li>\n<p>Loadable Components</p>\n<ul>\n<li>필요한 모듈만 import해서 성능을 좋게 하는 방법</li>\n<li>React.lazy, React.suspense도 존재하지만, SSR까지 커버 가능</li>\n</ul>\n</li>\n<li>\n<p>Stacking Context</p>\n<ul>\n<li>가상의 Z축을 사용한 HTML 요소의 3차원 개념</li>\n<li>즉, Z축을 사용할 때, 우선순위를 결정하는 개념 </li>\n<li>예를 들어 <code class=\"language-text\">z-index</code>를 비교하기 전에, 비교하는 Element의 부모에 <code class=\"language-text\">z-index</code>가 있는지 판단해야 하며, 부모의 <code class=\"language-text\">z-index</code>가 있다면 부모의 <code class=\"language-text\">z-index</code>와 비교해야 한다.</li>\n</ul>\n</li>\n<li>\n<p>좋은 함수란</p>\n<ul>\n<li>테스트 하기 쉽고, 파악하기 좋은 코드</li>\n<li>명시적 인풋과 아웃풋이 있다.</li>\n</ul>\n</li>\n<li>\n<p>react-slick 와 keen-slider 차이</p>\n<ul>\n<li>\n<p><code class=\"language-text\">react-slick</code></p>\n<ul>\n<li>React 기반으로 만든 carousel component이며 Slick.js 라이브러리로 만들어짐</li>\n<li>React를 통해 carousel과 slider를 쉽게 만들 수 있도록 제공</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">keen-slider</code></p>\n<ul>\n<li>가볍고 반응형 slider 라이브러리이며, 바닐라 JS와 CSS로 만들어짐</li>\n<li>React 의존성이 없음</li>\n<li>JS 프레임워크와 순수 JS로 사용할 수 있음</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>ReactSearchAutocomplete를 가져와 프로젝트 내부에 맞게 커스텀해서 작업을 했다. 그러나 리팩토링하기 전에 테스트 코드를 작성하는 과정에서 ReactSearchAutocomplete 자체에 <b>수많은 상태와 액션 함수</b>가 얽혀 있음을 알게 되었다. 즉, 테스트 코드 작성을 하기 너무 어려웠다. 또한 통합테스트에 대한 정확한 이해가 없어서 팀원분들에게 물어봐 알게된 내용을 밑에 정리했다.</p>\n<ul>\n<li>현재 테스트 하고자 하는, <code class=\"language-text\">ReactSearchAutocomplete</code> 안에 있는 <code class=\"language-text\">SearchInput</code> 와 <code class=\"language-text\">SearchResults</code> 컴포넌트를 테스트 하는 것보다는 <code class=\"language-text\">ReactSearchAutocomplete</code> 컴포넌트를 테스트 하는 것이 더 좋습니다. 왜냐하면 <code class=\"language-text\">SearchInput</code> 와 <code class=\"language-text\">SearchResults</code> 컴포넌트 사이의 관계가 너무 밀집되어 있기 때문</li>\n<li>FE 환경에서는 계산 테스트(유닛 테스트) 보다는, 액션에 대한 통합 테스트(E2E)가 더 중요</li>\n<li>계산에 대한 테스트 코드는 언제든지 변할 수 있지만, 통합테스트는 기획 요구사항과 맞닿아 있기 때문에, 잘 변하지 않음</li>\n<li>통합테스트를 하는 과정에서 MSW(API의 결과 or API 자체 Mocking)를 사용해서 특정 <code class=\"language-text\">액션</code>에 대한 원하는 요구사항(기획단계)을 테스트 하는 것</li>\n<li>특정 API가 성공 혹은 실패 할 때, 테스트 코드를 작성해야 함</li>\n<li>테스트 코드를 짤 때, <b>Given &#x26; When &#x26; Then</b> 의 시나리오로 테스트 코드 작성</li>\n<li>리팩토링의 중점은 액션을 밖으로 빼서 공통적으로 사용할 수 있도록 해야 합니다.</li>\n</ul>\n</li>\n</ol>\n<br>\n<h1 id=\"-반성\" style=\"position:relative;\"><a href=\"#-%EB%B0%98%EC%84%B1\" aria-label=\" 반성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🤔 반성</h1>\n<p>익숙하지 않은 것들을 접할 때마다, 조급함이 먼저 일어나는 것 같다. <b>왜 그럴까? 무의식적으로 내가 남들보다 뒤쳐져 있다는 불안감</b>이 있어서 그런 것 같다.</p>\n<p>사실 나만 그런 것이 아닌데, 모두가 다 그러한 것인데. 특히 요즘들어 멘탈 관리의 중요성을 많이 생각하게 된다. <code class=\"language-text\">일희일비</code>하지 않고 묵묵히 내가 해야 할 것들을 하자.\n쉽지 않지만, 그렇게 노력해야 나를 잃지 않을 것 겉다. </p>\n<p>지금까지 일을 하면서, 나도 모르게 아무것도 아닌 것에도 <code class=\"language-text\">죄송합니다</code>라는 말을 남용한 것 같다. 정작 주변은 아무것도 아닌 데, 괜히 나 혼자 죄송하다고 이게 겸손이라고 크게 착각 한 것 같다.</p>\n<p><b>죄송하다고 표현할 때<b/>는 정말 내가 누군가에게 피해를 입혀서, 그 사람이 마음과 몸이 상할 때 인것 같다. 그게 아니라면 굳이 죄송하다는 표현을 하지 말자.</p>\n<p>결국 별것도 아닌 것에 대해 죄송하다고 했던 표현들이, 지금까지 일으켰던 나의 자존감과 자의식을 갉아먹어버린 건 아닌가 싶다.</p>\n<p>그리고 타인을 위해, <b>일을 잘 하고 싶다</b>는 순수한 욕망보다는, 새로운 나의 가능성을 확인하는 순수한 욕망을 가진채 살아가고 싶다.</p>\n<br>\n<h3 id=\"참고\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0\" aria-label=\"참고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고</h3>\n<ul>\n<li><a href=\"https://reactjs.org/docs/code-splitting.html#reactlazy\">React.lazy</a></li>\n<li><a href=\"https://medium.com/greendatakr/loadable-components-881e936aa8fa\">loadable Components 사용 방법</a></li>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\">Staking Context</a></li>\n<li><a href=\"https://jojoldu.tistory.com/697\">좋은 함수 만들기</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EC%B0%B8%EA%B3%A0\">참고</a></li>\n</ul>\n</div>","excerpt":"✏️ 배운 내용 먼저 설날 연휴가 있다보니, 업무 보다는 개인 공부를 통해 배운 내용들을 적어본다. Code Spliting SPA 번들 사이즈가 커지면, 로딩 속도나 성능면에서 문제가 생기기 때문에 이것들을 여러개의 번들로 나누거나 동적으로 import 하는 기법 Loadable Components 필요한 모듈만 import해서 성능을 좋게 하는 방법 React.lazy, React.suspense도 존재하지만, SSR까지 커버 가능 Stacking Context 가상의 Z축을 사용한 HTML 요소의 3차원 개념 즉, Z축을 사용할 때, 우선순위를 결정하는 개념  예를 들어 를 비교하기 전에, 비교하는 Element의 부모에 가 있는지 판단해야 하며, 부모의 가 있다면 부모의 와 비교해야 한다. 좋은 함수란 테스트 하기 쉽고, 파악하기 좋은 코드 명시적 인풋과 아웃풋이 있다. react-slick 와 keen-slider 차이  React 기반으로 만든 carousel compon…","frontmatter":{"date":"January 28, 2023","title":"1월 4주 회고","categories":"Log","author":"Kay","emoji":"👋"},"fields":{"slug":"/write-log-230128/"}},"next":{"id":"d996c1e8-9ed3-5e73-bd28-693f27aa9537","html":"<h1 id=\"-내용\" style=\"position:relative;\"><a href=\"#-%EB%82%B4%EC%9A%A9\" aria-label=\" 내용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>👀 내용</h1>\n<ul>\n<li>\n<p>함수형 프로그래밍에서 가져갈 수 있는 것</p>\n<ul>\n<li><code class=\"language-text\">관점(체계)</code>을 제공 → 클린한 코드를 작성할 수 있습니다.</li>\n<li>함수형 프로그래밍의 대체제 = <code class=\"language-text\">OOP</code></li>\n<li>OOP → 관련된 데이터를 엮는 것</li>\n</ul>\n</li>\n<li>함수형 프로그래밍에서는 데이터를 재가공해서 보겠다는 의미</li>\n<li>액션 → 계산(명시적 입출력) → 액션(외부 상황에 영향을 주는 것)</li>\n<li>액션을 최소화 하고, 계산을 많이 만듭니다.</li>\n<li>\n<p>사용자가 할 수 있는 행동 = 요구사항</p>\n<ul>\n<li><code class=\"language-text\">요구 사항 → 계산 → DOM 조작(화면이 바뀌는 것)</code></li>\n<li>유사한 계층을 정리 정돈 = PIPE → 이름을 명시</li>\n<li>다양한 요구사항에 유연적으로 대응할 수 있는지 확인</li>\n</ul>\n</li>\n<li>결국 사용사의 요구 사항에 맞게 데이터를 계산해서 계산된 데이터를 화면에 업데이트 하는 과정</li>\n</ul>\n<br>\n<h1 id=\"️-실습\" style=\"position:relative;\"><a href=\"#%EF%B8%8F-%EC%8B%A4%EC%8A%B5\" aria-label=\"️ 실습 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>✏️ 실습</h1>\n<ul>\n<li>하나의 프로젝에서 액션 - 계산 - 데이터를 나누는 실습을 진행</li>\n<li>계산을 <code class=\"language-text\">도메인, 비즈니스 로직, 타입 컨벌트, 포메터</code>로 나누는 실습을 진행</li>\n<li>또한 이러한 계산을 하나의 Hook안에 작성한다고 생각할 수 있음</li>\n</ul>\n<br>\n<h3 id=\"참고\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0\" aria-label=\"참고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고</h3>\n<ul>\n<li><a href=\"https://github.com/FECrash/FunctionalProgramming\">함수형 프로그래밍 스터디</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EC%B0%B8%EA%B3%A0\">참고</a></li>\n</ul>\n</div>","frontmatter":{"date":"January 27, 2023","title":"함수형 프로그래밍 - 스터디 4주차","categories":"Study","author":"Kay","emoji":"👨‍💻"},"fields":{"slug":"/study-js-functionalProgramming-4/"}},"prev":{"id":"2f7f4b8a-672b-5c27-93bd-2f2f6d7ed6be","html":"<h1 id=\"facts\" style=\"position:relative;\"><a href=\"#facts\" aria-label=\"facts permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Facts</h1>\n<ul>\n<li>ORM에 대한 개념이 궁금해졌다.</li>\n</ul>\n<br/>\n<h1 id=\"feelings\" style=\"position:relative;\"><a href=\"#feelings\" aria-label=\"feelings permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Feelings</h1>\n<ul>\n<li>회사 프로젝트 내부에 ORM이 존재했는데, ORM에 대해 자세히 알아보지 않았다. 부끄러웠다.</li>\n</ul>\n<br/>\n<h1 id=\"findings\" style=\"position:relative;\"><a href=\"#findings\" aria-label=\"findings permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Findings</h1>\n<ul>\n<li>\n<p>개념</p>\n<ul>\n<li>ORM(Object Relational Model)은 사물을 추상화시켜 이해하려는 OOP적 사고방식과 DataModel을 정형화하여 관리하는 RDB 사이를 연결할 계층의 역할로 제시된 패러다임으로 RDB의 모델을 OOP에 Entity 형태로 투영시키는 방식을 사용한다.</li>\n<li>즉, Object와 DB간에 연결 역할을 해주는녀석이 ORM이다.</li>\n</ul>\n</li>\n<li>\n<p>등장 배경</p>\n<ul>\n<li>ORM을 사용하지 않을 경우 개발자가 개발 하기위해 DB에 접근하기 위해서는 SQL Query문을 직접 만들었다.</li>\n<li>SQL문법을 알고 있어야하기 때문에 쿼리문 작성시간이 오래걸려 개발이 지체되는 문제가 발생했다.</li>\n<li>개발 코드와 DB가 서로 종속되는 문제가 생겨나기 시작했다.</li>\n<li>이러한 문제점을 해결하기 위해 ORM이 등장하였고 ORM이 등장함으로서 SQL Query 문법에서 비교적 자유로워졌으며 개발 코드와 DB를 분리함으로써 객체지향의 의도에 부합하게 되었다.</li>\n</ul>\n</li>\n<li>\n<p>ORM 사용 장점과 단점</p>\n<ul>\n<li>장점</li>\n<li>선언문, 할당, 종료 등과같은 부수적인 코드가 사라짐으로써 개발의 생산성 향상.</li>\n<li>명확한 쿼리 (버그와 실수 감소)</li>\n<li>코드그 간결하고 직관이기 때문에 가독성을 높여준다.</li>\n<li>DB 의존성 감소</li>\n<li>특정 Database에 종속적이지 않다.</li>\n<li>개발자는 DB에 상관없이 Object에만 집중할 수 있다.</li>\n<li>단점</li>\n<li>튜닝의 어려움</li>\n<li>미세한 수정 및 디버그하기가 상대적으로 어렵다</li>\n<li>복잡한 쿼리작성의 문제</li>\n<li>ORM이 지정해 놓은 명령만 내릴 수 있다</li>\n<li>DB에 직접 명령을 내리지 않고 한단계 거쳐가기 때문에 Raw쿼리에 비해 느린 실행속도 발생</li>\n</ul>\n</li>\n</ul>\n<br>\n<h3 id=\"참고\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0\" aria-label=\"참고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고</h3>\n<p><a href=\"https://kyungyeon.dev/posts/3\">ORM Node.js에서 사용하기</a></p>","frontmatter":{"date":"January 29, 2023","title":"TIL - 230129","categories":"TIL","author":"Kay","emoji":"🤔"},"fields":{"slug":"/til-230129/"}},"site":{"siteMetadata":{"siteUrl":"https://free-ko.github.io","comments":{"utterances":{"repo":"zoomkoding/zoomkoding-gatsby-blog"}}}}},"pageContext":{"slug":"/write-log-230128/","nextSlug":"/study-js-functionalProgramming-4/","prevSlug":"/til-230129/"}},"staticQueryHashes":["1073350324","2938748437"]}