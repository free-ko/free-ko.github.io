{"componentChunkName":"component---src-templates-blog-template-js","path":"/write-log-231216/","result":{"data":{"cur":{"id":"4bb5cacf-864b-580c-9aad-bc5a9fa3ecce","html":"<h2 id=\"회고\" style=\"position:relative;\"><a href=\"#%ED%9A%8C%EA%B3%A0\" aria-label=\"회고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>회고</h2>\n<h3 id=\"업무-회고\" style=\"position:relative;\"><a href=\"#%EC%97%85%EB%AC%B4-%ED%9A%8C%EA%B3%A0\" aria-label=\"업무 회고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>업무 회고</h3>\n<ul>\n<li>개발을 하면서 타입스크립트의 장점을 느낀 것 중에 하나가, API Request Data와 Response Data Type을 지정해 놓으면 일일히 BE분께서 제공해주신 Swagger를 참고할 필요가 없다는 사실이다. 또한 BE분과 협업하면서 Request와 Response 타입이 다른 부분에 대해 디테일하게 물어보면서 협업할 수 있어 좋았다.</li>\n<li>우리가 최종으로 보는 것은 타입이다.(props, return 타입)</li>\n<li>시간 압박에 의해 any 타입을 사용하고 싶은 욕구가 많지만, 최대한 차분히 타입 에러를 해결하는 연습이 필요하다.</li>\n<li>불필요한 삼항연산자 사용을 줄이자. ex) <code class=\"language-text\">setName(name === 'ko' ? true : false)</code> -> <code class=\"language-text\">setName(name === 'ko')</code></li>\n<li>스프린트 일정을 잡을 때에는 리서치 부분도 고려해서 업무 일정을 작성해야 하고 리팩토링 일정에 대해서는 미리 팀에게 리팩토링해야할 부분에 대해 리스트 업을 한 다음에 다 함께 공유해서 마일스톤에 지장가지 않은 선에서 리팩토링 업무 일정을 잡아야 함. 스프린트 일정은 단순히 개인의 업무를 하는 것이 아닌, 팀의 마일스톤을 달성하기 위한 일정 작성이기 때문에 팀에게 미리 공유하고 작성해야 한다.</li>\n<li>불필요한 파일 생성은 지양. 특히 재 사용하지 않은 코드에 대해서 무조건 적으로 파일을 분리해서 작성하는 것 지양</li>\n<li>맵핑을 사용하는 이유는 if문과 switch문 보다 개인적으로 가독성 측면에서 좋다고 판단된다. 또한 BE에서 API 응답 값에 따라 특정 로직이나 UI를 렌더링 해야하는 상황에도 사용해도 좋은 것 같다. 그러나 무조건적으로 사용하는것은 지양해야 한다.</li>\n<li>하나의 함수는 하나의 역할만 하도록 작성해야 한다. 하나의 함수 안에 무언가 추가적으로 하는 작업이 있다면, 디버깅할 때 시간도 많이 걸린다.</li>\n<li>개발은 결국 ‘문제 해결’을 하는 것이다. 함수를 만들던, 객체를 만들던 결국 작은 문제 해결 방법 도구들을 만들어서(이 때, 작은 단위로 만들어야 함) 진정으로 내가 해결하고자 하는 문제 해결을 할 수 있다. 그래서 개발 하기 전에 항상 바로 개발하는 것이 아닌, 미리 ‘설계도’를 작성하면서 개발을 하는 습관을 들이자.</li>\n<li>스스로 개발하면서 중복적인 코드가 눈에 많이 보인다면, 무조건 ‘문제’라고 인식하자. 그리고 최대한 ‘중복’ 코드를 줄이자.</li>\n<li>항상 ‘이유’를 생각하면서 개발을 해야 한다.</li>\n<li>특정 문서의 튜토리얼을 사용할 때에는 무조건적으로 가져오는게 아닌, 내가 직면한 문제를 해결하기 위해 사용되어야 한다. 주객이 전도되면 안된다.</li>\n<li>PR을 하기 앞서, 더 나아가 개발을 하기 앞서 개발의 방향성이 잘 안 잡힐 때 팀에게 물어보고 개발을 하게 되면 PR 리뷰 수도 줄어들고 무엇보다 팀의 타임 리소스를 줄일 수 있다.</li>\n<li>새로운 기술(패키지, 라이브러리 등)을 도입할 때에는 다양한 비용을 고려해야 한다. 먼저 팀원분들이 익순한 기술인지, 혹여 새로운 기술을 도입했을 때 러닝 커브나 시간은 얼마나 걸릴지, 이로 인해 갑작스럽게 핫픽스 대응 할 수 있는데 악영향을 주지는 않는지 등을 말이다. 결국 새로운 기술을 도입하는 가장 큰 이유는 ‘문제 해결’이다. mantine이 제공해주는 useForm을 통해서도 form 기능을 구현할 수 있지만, 현재 팀내에서 React Hook Form을 사용하고 있고, 기능적으로 더 많은 이점이 존재하기 때문에 안쓸 이유가 없었다. 나는 그것도 인지 하지 못한 채로 mantine의 useForm을 ‘그냥’사용했다. 이 부분은 정말 스스로 반성하는 계기가 되었다.</li>\n</ul>\n<br>\n<h2 id=\"마무리\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-label=\"마무리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마무리</h2>\n<p>매일 매일 첼린지 하는 기분이 든다.\nPR 리뷰를 받을 때, 조마조마한 기분과 숨고 싶은 마음이 굴뚝같이 솟았다.</p>\n<p>‘왜 이럴까’에 대해 팀원분들의 피드백을 듣고나서 알게 되었다. 결국 내가 ‘왜’를 놓치고 개발하고 있음을 깨닫게 되었다.\n더 나아가, 나의 삶에서 ‘왜’가 빠져있음도 알게 되었다.</p>\n<p>이번 피드백과 회고를 통해서 ‘문제’를 정확하게 인지하고, ‘왜’ 이 ‘문제’를 해결하고 싶은지,</p>\n<p>그리고 이 ‘문제’를 해결하기 위해 어떠한 ‘과정’으로 해결해 나아갈지 먼저 개발하면서 위의 사고를 연습하고 습관하 한다면,</p>\n<p>내 ‘삶’에서도 ‘이유’를 찾는 데 도움을 줄 것이라 확신이 든다.</p>\n<p>이번 한 주도 수고했다.</p>\n<br>\n<h3 id=\"참고\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0\" aria-label=\"참고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고</h3>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%ED%9A%8C%EA%B3%A0\">회고</a></p>\n<ul>\n<li><a href=\"#%EC%97%85%EB%AC%B4-%ED%9A%8C%EA%B3%A0\">업무 회고</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\">마무리</a></p>\n<ul>\n<li><a href=\"#%EC%B0%B8%EA%B3%A0\">참고</a></li>\n</ul>\n</li>\n</ul>\n</div>","excerpt":"회고 업무 회고 개발을 하면서 타입스크립트의 장점을 느낀 것 중에 하나가, API Request Data와 Response Data Type을 지정해 놓으면 일일히 BE분께서 제공해주신 Swagger를 참고할 필요가 없다는 사실이다. 또한 BE분과 협업하면서 Request와 Response 타입이 다른 부분에 대해 디테일하게 물어보면서 협업할 수 있어 좋았다. 우리가 최종으로 보는 것은 타입이다.(props, return 타입) 시간 압박에 의해 any 타입을 사용하고 싶은 욕구가 많지만, 최대한 차분히 타입 에러를 해결하는 연습이 필요하다. 불필요한 삼항연산자 사용을 줄이자. ex)  ->  스프린트 일정을 잡을 때에는 리서치 부분도 고려해서 업무 일정을 작성해야 하고 리팩토링 일정에 대해서는 미리 팀에게 리팩토링해야할 부분에 대해 리스트 업을 한 다음에 다 함께 공유해서 마일스톤에 지장가지 않은 선에서 리팩토링 업무 일정을 잡아야 함. 스프린트 일정은 단순히 개인의 업무를 하는…","frontmatter":{"date":"December 16, 2023","title":"12월 3주 회고","categories":"Log","author":"Kay","emoji":"👋"},"fields":{"slug":"/write-log-231216/"}},"next":{"id":"f3d58be0-0414-5ae1-b8f1-0322bd9a6846","html":"<h2 id=\"들어가기-앞서\" style=\"position:relative;\"><a href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0-%EC%95%9E%EC%84%9C\" aria-label=\"들어가기 앞서 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>들어가기 앞서</h2>\n<ul>\n<li>유일하게 변하지 않는 것은 모든 것이 변한다는 사실 뿐</li>\n<li>여행 중 길을 찾는 방법은 크게 두 가지로 나눌 수 있음</li>\n<li>\n<p>기능적이고 해결책 지향적인 접근법</p>\n<ul>\n<li>다른 사람에게 길을 물어봄</li>\n<li>올바른 길을 알려줬다면 원하는 곳으로 이동할 수 있겠지만, 이 방법은 일반적이지도, 재사용 가능하지도 않음</li>\n<li>또 중요한 랜드마크가 없다면 설명만으로 경로를 찾기 쉽지 않음</li>\n</ul>\n</li>\n<li>\n<p>구조적이고 문제 지향적인 접근법</p>\n<ul>\n<li>지도를 이용</li>\n<li>길을 찾는 데 필요한 풍부한 컨텍스트 정보가 함축돼 있으며, 길을 묻는 방법보다 쉽고 간단</li>\n<li>주변 지형을 추상적으로 표현하기 때문에 실세계의 환경과 우리의 지식을 밀접하게 연관 지을 수 있게 해줌</li>\n<li>지도는 다양한 목적을 위해 재사용될 수 있으며, 범용적. ‘기능’에 대한 요구사항이 계속 변해도 지도에 표시된 ‘구조’는 안정적이기 때문</li>\n<li>지도 은유의 핵심은, 기능이 아니라 구조를 기반으로 모델을 구축하는 편이 좀 더 범용적이고 이해하기 쉬우며 변경에 안정적이라는 것.</li>\n<li>객체지향 개발 방법은 안정적인 구조에 변경이 빈번하게 발생하는 기능을 종속시키는 지도의 방법과 유사함</li>\n</ul>\n</li>\n<li>자주 변경되는 기능이 아니라, 안정적인 구조를 따라 역할 책임, 협력을 구성</li>\n</ul>\n<br>\n<h2 id=\"기능-설계-대-구조-설계\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EB%8A%A5-%EC%84%A4%EA%B3%84-%EB%8C%80-%EA%B5%AC%EC%A1%B0-%EC%84%A4%EA%B3%84\" aria-label=\"기능 설계 대 구조 설계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기능 설계 대 구조 설계</h2>\n<ol>\n<li>\n<p>기능 측면의 설계</p>\n<ul>\n<li>제품이 사용자를 위해 무엇을 할 수 있는지에 초점</li>\n</ul>\n</li>\n<li>\n<p>구조 측면의 설계</p>\n<ul>\n<li>제품의 형태가 어떠해야 하는지에 초점</li>\n</ul>\n</li>\n<li>훌륭한 구조는 훌륭한 소프트웨어를 만들기 위한 필요조건.</li>\n<li>훌륭한 설계는 불가능한 요구사항 변경에도 유연하게 대처할 수 있는 안정적인 구조를 제공해야 함</li>\n<li>미래를 대비하는 가장 좋은 방법은 변경을 예측하는 것이 아니라, 변경을 수용할 수 있는 선택의 여지를 설계에 마련해 놓는 것.</li>\n<li>설계를 하는 목적은 나중에 설계하는 것을 허용하는 것이며, 설계의 일차적인 목표는 변경에 소요되는 비용을 낮추는 것.</li>\n<li>객체지향 접근방법은 자주 변경되지 않는 안정적인 객체 구조를 바탕으로 시스템 기능을 객체 간의 책임으로 분배.</li>\n<li>객체지향은 객체의 구조에 집중하고 기능이 객체의 구조를 따르게 만듦. 기능이 변경되더라도 객체 간의 구조는 그대로 유지됨.</li>\n</ol>\n<br>\n<h2 id=\"두-가지-재료-기능과-구조\" style=\"position:relative;\"><a href=\"#%EB%91%90-%EA%B0%80%EC%A7%80-%EC%9E%AC%EB%A3%8C-%EA%B8%B0%EB%8A%A5%EA%B3%BC-%EA%B5%AC%EC%A1%B0\" aria-label=\"두 가지 재료 기능과 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>두 가지 재료: 기능과 구조</h2>\n<ol>\n<li>\n<p>기능</p>\n<ul>\n<li>사용자가 자신의 목표를 달성하기 위해 사용할 수 있는 시스템의 서비스</li>\n</ul>\n</li>\n<li>\n<p>구조</p>\n<ul>\n<li>시스템의 기능을 구현하기 위한 기반으로, 기능 변경을 수용할 수 있도록 안정적이여야 함.</li>\n</ul>\n</li>\n</ol>\n<br>\n<h2 id=\"안정적인-재료-구조\" style=\"position:relative;\"><a href=\"#%EC%95%88%EC%A0%95%EC%A0%81%EC%9D%B8-%EC%9E%AC%EB%A3%8C-%EA%B5%AC%EC%A1%B0\" aria-label=\"안정적인 재료 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>안정적인 재료: 구조</h2>\n<ol>\n<li>\n<p>도메인 모델</p>\n<ul>\n<li>사용자가 프로그램을 사용하는 대상 분야를 도메인이라고 함.</li>\n<li>도메인 모델에서 모델이란 대상을 단순화해서 표현한 것으로, 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태</li>\n<li>즉 도메인 모델은 소프트웨어가 목적하는 영역 내의 개념과 개념 간의 관계, 다양한 규칙이나 제약 등을 주의 깊게 추상화한 것</li>\n<li>도메인 모델은 이해관계자들이 바라보는 멘탈 모델(Mental Model)</li>\n<li>소프트웨어 사용자들은 도메인에 존재하는 현상을 이해하고 현상에 반응하기 위해 도메인과 관련된 멘탈 모델을 형성함</li>\n</ul>\n</li>\n<li>\n<p>도메인의 모습을 담을 수 있는 객체지향</p>\n<ul>\n<li>최종 코드는 사용자가 도메인을 바라보는 관점을 반영해야 함.</li>\n<li>즉 애플리케이션은 도메인 모델을 기반으로 설계돼야 함.</li>\n<li>객체지향은 도메인 모델의 세 가지 측면(사용자, 디자인, 시스템 이미지)을 모두 모델링할 수 있는 거의 유일한 모델링 패러다임.</li>\n<li>객체지향은 사람들이 만지고 느끼고 볼 수 있는 실체를 시스템 안의 객체로 재창조할 수 있게 해줌</li>\n</ul>\n</li>\n<li>\n<p>표현적 차이</p>\n<ul>\n<li>소프트웨어 객체는 현실 객체에 대한 추상화가 아니라, 은유를 기반으로 재창조한 것</li>\n<li>소프트웨어 객체와 현실 객체 사이의 의미적 거리를 가리켜 표현적 차이 또는 의미적 차이라고 함</li>\n<li>소프트웨어 객체는 그 대상이 현실적인지, 현실적이지 않은지에 상관없이 도메인 모델을 통해 표현되는 도메인 객체들을 은유해야 함.</li>\n<li>도메인 모델을 기반으로 설계하고 구현하는 것은 사용자가 도메인을 바라보는 관점을 그대로 코드에 반영할 수 있게 하며, 결과적으로 표현적 차이가 줄어들 것.</li>\n<li>도메인 모델은 코드 안에 존재하는 미로를 헤쳐나갈 수 있는 지도를 제공함</li>\n</ul>\n</li>\n<li>\n<p>불안정한 기능을 담는 안정적인 도메인 모델</p>\n<ul>\n<li>도메인 모델이 제공하는 구조는 상대적으로 안정적.</li>\n<li>도메인 모델의 핵심은 사용자가 도메인을 바라보는 관점을 반영해 소프트웨어를 설계하고 구현하는 것.</li>\n<li>본질적인 측면을 가장 잘 반영한 사용자 모델을 기반으로 설계와 코드를 만들면 변경에 쉽게 대처할 수 있을 가능성이 커짐</li>\n<li>결론적으로 안정적인 구조를 제공하는 도메인 모델을 기반으로 소프트웨어의 구조를 설계하면 변경에 유연하게 대응할 수 있는 탄력적인 소프트웨어를 만들 수 있음</li>\n</ul>\n</li>\n</ol>\n<br>\n<h2 id=\"불안정한-재료-기능\" style=\"position:relative;\"><a href=\"#%EB%B6%88%EC%95%88%EC%A0%95%ED%95%9C-%EC%9E%AC%EB%A3%8C-%EA%B8%B0%EB%8A%A5\" aria-label=\"불안정한 재료 기능 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>불안정한 재료: 기능</h2>\n<ol>\n<li>\n<p>유스케이스</p>\n<ul>\n<li>훌륭한 기능적 요구사항을 얻기 위해서는 목표를 가진 사용자와 사용자의 목표를 만족시키기 위해 일련의 절차를 수행하는 시스템 간의 ‘상호작용’ 관점에서 시스템을 바라봐야 함</li>\n<li>사용자의 목표를 달성하기 위해 사용자와 시스템 간에 이뤄지는 상호작용의 흐름을 텍스트로 정리한 것을 유스케이스라고 함</li>\n<li>유스케이스는 시스템의 이해관계자들 간의 계약을 행위 중심으로 파악함.</li>\n<li>산발적으로 흩어져 있는 기능에 사용자 목표라는 문맥을 제공함으로써 각 기능이 유기적인 관계를 지닌 체계를 이룰 수 있게 함</li>\n<li>사용자 목표가 유스케이스의 핵심. 유스케이스는 공통의 사용자 목표를 통해 강하게 연관된 시나리오의 집합</li>\n</ul>\n</li>\n<li>\n<p>유스케이스의 특성</p>\n<ul>\n<li>유스케이스는 사용자와 시스템 간의 상호작용을 보여주는 ‘텍스트’. 유스케이스는 다이어그램이 아님</li>\n<li>유스케이스는 하나의 시나리오가 아니라 여러 시나리오들의 집합. 시나리오는 유스케이스를 통해 시스템을 사용하는 하나의 특정한 이야기 또는 경로. 시나리오를 유스케이스 인스턴스라고도 함</li>\n<li>유스케이스는 단순한 피처(feature) 목록과 다름. 피처는 시스템이 수행해야 하는 기능의 목록을 단순하게 나열한 것. 유스케이스는 단순히 기능을 나열한 것이 아니라 이야기를 통해 연관된 기능을 함께 묶을 수 있음</li>\n<li>유스케이스는 사용자 인터페이스와 관련된 세부 정보를 포함하지 말아야 함. 유스케이스는 자주 변경되는 사용자 인터페이스 요소는 배제하고 사용자 관점에서 시스템의 행위에 초점을 맞춤</li>\n<li>유스케이스는 내부 설계와 관련된 정보를 포함하지 않음</li>\n</ul>\n</li>\n<li>\n<p>유스케이스는 설계 기법도, 객체지향 기법도 아님</p>\n<ul>\n<li>유스케이스는 단지 사용자가 바라보는 시스템의 외부 관점만을 표현. 유스케이스로부터 시스템의 내부 구조를 유추할 수는 없음</li>\n<li>유스케이스와 객체의 구조 사이에는 커다란 간격이 존재하며, 이 간격을 자동으로 없앨 수 없음. 유스케이스는 객체의 구조나 책임에 대한 어떤 정보도 제공하지 않음</li>\n</ul>\n</li>\n</ol>\n<br>\n<h2 id=\"재료-합치기-기능과-구조의-통합\" style=\"position:relative;\"><a href=\"#%EC%9E%AC%EB%A3%8C-%ED%95%A9%EC%B9%98%EA%B8%B0-%EA%B8%B0%EB%8A%A5%EA%B3%BC-%EA%B5%AC%EC%A1%B0%EC%9D%98-%ED%86%B5%ED%95%A9\" aria-label=\"재료 합치기 기능과 구조의 통합 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>재료 합치기: 기능과 구조의 통합</h2>\n<ol>\n<li>\n<p>도메인 모델, 유스케이스, 그리고 책임-주도 설계</p>\n<ul>\n<li>변경에 유연한 소프트웨어를 만들기 위해서는 유스케이스에 정리된 시스템의 기능을 도메인 모델을 기반으로 한 객체들의 책임으로 분배해야함</li>\n<li>시스템은 사용자로부터 전송된 메시지를 수행하기 위해 책임을 수행하는 거대한 자율적인 객체.</li>\n<li>시스템 안에는 더 작은 규모의 객체들이 협력을 통해 구현됨.</li>\n<li>시스템에 할당된 커다란 책임은 시스템 안의 작은 규모의 객체들이 수행해야 하는 더 작은 규모의 책임으로 세분화됨</li>\n<li>도메인 모델에 포함된 개념을 은유하는 소프트웨어 객체를 선택하고, 협력을 완성하는 데 필요한 메시지를 식별하면서 객체들에게 책임을 할당해 나감.</li>\n<li>마지막으로 협력에 참여하는 객체를 구현하기 위해 클래스를 추가하고 속성과 함께 메서드를 구현하면 시스템의 기능이 완성됨</li>\n<li>유스케이스는 사용자에게 제공할 기능을 시스템의 책임으로 보게 함으로써 객체 간의 안정적인 구조에 책임을 분배할 수 있는 출발점을 제공함.</li>\n<li>도메인 모델을 기능을 수용하기 위해 은유할 수 있는 안정적인 구조를 제공함</li>\n<li>책임-주도 설계 방법은 시스템의 기능을 역할과 책임을 수행하는 객체들의 협력 관계로 바라보게 함으로써 유스케이스와 도메인 모델을 통합함.</li>\n<li>견고한 객체지향 애플리케이션을 개발하기 위해서는 사용자의 관점에서 시스템으 기능을 명시하고, 사용자와 설계자가 공유하는 안정적인 구조를 기반으로 기능을 책임으로 변환하는 체계적인 절차를 따라야 함</li>\n<li>유스케이스에서 출발해 객체들의 협력으로 이어지는 일련의 흐름은 객체 안에 다른 객체를 포함하는 재귀적 합성이라는 객체지향의 기본 개념을 잘 보여줌</li>\n<li>객체지향은 모든 것을 객체로 바라봄다. 크기와 상관없이 모든 객체는 메시지를 전송하거나 수신할 수 있고 메시지에 응답하기 위해 자율적으로 메서드를 선택할 수 있음</li>\n</ul>\n</li>\n<li>\n<p>기능 변경을 흡수하는 안정적인 구조</p>\n<ul>\n<li>도메인 모델이 안정적인 이유는 2가지</li>\n<li>첫째, 도메인 모델을 구성하는 개념은 비즈니스가 없어지거나 완전히 개편되지 않는 한 안정적으로 유지됨</li>\n<li>둘째, 도메인 모델을 구서하는 개념 간의 관계는 비즈니스 규칙을 기반으로 하기 때문에 비즈니스 정책이 크게 변경되지 않는 한 안정적으로 유지됨</li>\n<li>객체지향의 가장 큰 장점은 도메인을 모델링하기 위한 기법과 도메인을 프로그래밍하기 위해 사용하는 기법이 동일하다는 점. 따라서 도메인 모델링에서 사용한 객체와 개념을 프로그래밍 설계에서의 객체와 클래스로 매끄럽게 변환할 수 있음. 객체지향의 이 같은 특성을 연결완전성이라고 함</li>\n<li>연결완전성의 역방향 역시 성립함. 즉 코드의 변경으로부터 도메인 모델의 변경 사항을 유추할 수 있음. 이것을 가역성이라고 함</li>\n<li>안정적인 도메인 모델을 기반으로 시스템의 기능을 구현하고, 도메인 모델과 코드를 밀접하게 연관시키기 위해 노력</li>\n</ul>\n</li>\n</ol>\n<br>\n<h2 id=\"참고\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0\" aria-label=\"참고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고</h2>\n<ul>\n<li><a href=\"https://www.yes24.com/Product/Goods/18249021\">객체지향의 사실과 오해</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0-%EC%95%9E%EC%84%9C\">들어가기 앞서</a></li>\n<li><a href=\"#%EA%B8%B0%EB%8A%A5-%EC%84%A4%EA%B3%84-%EB%8C%80-%EA%B5%AC%EC%A1%B0-%EC%84%A4%EA%B3%84\">기능 설계 대 구조 설계</a></li>\n<li><a href=\"#%EB%91%90-%EA%B0%80%EC%A7%80-%EC%9E%AC%EB%A3%8C-%EA%B8%B0%EB%8A%A5%EA%B3%BC-%EA%B5%AC%EC%A1%B0\">두 가지 재료: 기능과 구조</a></li>\n<li><a href=\"#%EC%95%88%EC%A0%95%EC%A0%81%EC%9D%B8-%EC%9E%AC%EB%A3%8C-%EA%B5%AC%EC%A1%B0\">안정적인 재료: 구조</a></li>\n<li><a href=\"#%EB%B6%88%EC%95%88%EC%A0%95%ED%95%9C-%EC%9E%AC%EB%A3%8C-%EA%B8%B0%EB%8A%A5\">불안정한 재료: 기능</a></li>\n<li><a href=\"#%EC%9E%AC%EB%A3%8C-%ED%95%A9%EC%B9%98%EA%B8%B0-%EA%B8%B0%EB%8A%A5%EA%B3%BC-%EA%B5%AC%EC%A1%B0%EC%9D%98-%ED%86%B5%ED%95%A9\">재료 합치기: 기능과 구조의 통합</a></li>\n<li><a href=\"#%EC%B0%B8%EA%B3%A0\">참고</a></li>\n</ul>\n</div>","frontmatter":{"date":"December 12, 2023","title":"객체지향의 사실과 오해 - 6장","categories":"Study","author":"Kay","emoji":"👋"},"fields":{"slug":"/oop-fact-and-misunderstand-6/"}},"prev":{"id":"1d75f8b5-97ab-563b-8958-49bb13c2eb65","html":"<h2 id=\"추상화-기법\" style=\"position:relative;\"><a href=\"#%EC%B6%94%EC%83%81%ED%99%94-%EA%B8%B0%EB%B2%95\" aria-label=\"추상화 기법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>추상화 기법</h2>\n<ul>\n<li>도메인에 존재하는 개념들을 구조화하고 단순화하기 위해 다양한 추상화 기법을 사용할 수 있음</li>\n<li>주요 추상화 기법의 종류들: 분류와 인스턴스화, 일반화와 특수화, 집합과 분해</li>\n<li>객체지향의 가장 큰 장점은 동일한 추상화 기법을 프로그램의 분석, 설계, 구현 단계에 걸쳐 일관성 있게 적용할 수 있다는 점</li>\n</ul>\n<br>\n<h2 id=\"분류와-인스턴스화\" style=\"position:relative;\"><a href=\"#%EB%B6%84%EB%A5%98%EC%99%80-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4%ED%99%94\" aria-label=\"분류와 인스턴스화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>분류와 인스턴스화</h2>\n<ol>\n<li>\n<p>개념과 범주</p>\n<ul>\n<li>도로 위를 달리는 작은 승용차와 버스, 트럭들을 가리켜 ‘자동차’라고 하며, 길거리에 자라고 있는 다양한 종류의 가로수들을 일컬어 ‘나무’라고 할 수 있음</li>\n<li>개별 자동차와 나무는 완전히 동일하지 않지만 유사한 특성을 바탕으로 각각 ‘자동차’와 ‘나무’로 분류할 수 있음.</li>\n<li>이처럼 객체를 분류하고 범주로 묶는 것은 객체들의 특정 집합에 공통의 개념을 적용하는 것을 의미함</li>\n<li>자동차: 바퀴를 이용해 사람들을 한 장소에서 다른 장소로 운반하는 운송수단 (이라는 특징)</li>\n<li>나무: 푸른 잎과 갈색의 줄기를 가진 다년생 식물 (이라는 특징)</li>\n<li>세상에 존재하는 객체에 개념을 적용하는 과정을 분류라고 함.</li>\n<li>분류는 객체를 특정한 개념을 나타내는 집합의 구성 요소로 포함시킴. 이때 ‘수많은 개별적인 현상들’을 객체라고 하고, ‘하나의 개념’을 타입이라고 함.</li>\n<li>분류는 객체를 타입과 연관시키는 것</li>\n<li>객체지향의 세계에서 타입은 개념과 동의어이며 속성과 행위가 유사한 객체에 공통적으로 적용되는 관념이나 아이디어를 의미. 객체는 자동으로 타입의 인스턴스라고 함</li>\n</ul>\n</li>\n<li>\n<p>타입</p>\n<ul>\n<li>객체를 타입에 따라 분류하기 위해서는 객체가 타입에 속하는지 여부를 확인할 수 있어야 함. 타입은 세 가지 관점에서의 정의가 필요.</li>\n<li>심볼: 타입을 가리키는 간략한 이름이나 명칭</li>\n<li>내연: 타입의 완전한 정의</li>\n<li>외연: 타입에 속하는 모든 객체들의 집합</li>\n</ul>\n</li>\n<li>\n<p>ex) 자동차</p>\n<ul>\n<li>심볼: 자동차</li>\n<li>내연: 원동기를 동력원으로 해서 주행하는 사람이나 화물을 운반하는 기계</li>\n<li>외연: 모든 자동차들의 집합\n→ 도메인을 분석하는 동안 이름(심볼)과 의미(내연), 객체들의 집합(외연)을 이용해 개념을 정의할 수 있음</li>\n</ul>\n</li>\n<li>\n<p>외연과 집합</p>\n<ul>\n<li>타입의 외연은 타입에 속하는 객체들의 집합</li>\n<li>단일 분류: 한 객체가 한 시점에 하나의 타입에만 속하는 것</li>\n<li>다중 분류: 한 객체가 한 시점에 여러 타입에 속하는 것</li>\n<li>대부분의 객체지향 프로그래밍 언어들은 단일 분류만을 지원. 한 객체는 오로지 한 클래스의 인스턴스여야만 함</li>\n<li>동적 분류: 객체가 한 집합에서 다른 집합의 원소로 자신이 속하는 타입을 변경할 수 있는 경우</li>\n<li>정적 분류: 객체가 자신의 타입을 변경할 수 없는 경우</li>\n<li>대부분의 언어에서는 동적 분류를 구현할 수 있는 방법을 제공하지 않음.</li>\n<li>다중 분류와 동적 분류 관점에서 도메인 모델의 초안을 만든 후 실제 구현에 적합하도록 단일 분류와 정적 분류 방식으로 객체들의 범주를 재조정하는 편이 분석과 구현 간의 차이를 메울 수 있는 가장 현실적인 방법</li>\n</ul>\n</li>\n<li>\n<p>클래스</p>\n<ul>\n<li>객체지향 프로그래밍 언어를 이용해 타입을 구현하는 가장 보편적인 방법은 클래스를 이용하는 것</li>\n<li>아리스토텔레스 철학에서 비롯된 현재의 객체지향 패러다임에서는 만약 객체들이 동일한 특성을 가진다면 그것들은 동일한 카테고리에 속함.</li>\n<li>객체들의 카테고리는 객체들이 공유하는 공통적인 특성에 의해 정의됨</li>\n<li>객체의 특성을 사물의 가장 핵심적이고 필수불가결한 ‘본질’과 그렇지 않은 ‘우연’적인 속성으로 나눌 수도 있음.</li>\n<li>객체지향 언어에서 클래스는 객체가 공유하는 본질적인 속성을 정의함. 동일한 범주에 속하는 객체는 모두 동일한 속성을 가져야만 한함</li>\n<li>자바스크립트와 같은 프로토타입 기반의 언어에서 분류와 인스턴스화는 프로토타입이라는 객체의 복사를 통해 이뤄짐</li>\n</ul>\n</li>\n</ol>\n<br>\n<h2 id=\"일반화와-특수화\" style=\"position:relative;\"><a href=\"#%EC%9D%BC%EB%B0%98%ED%99%94%EC%99%80-%ED%8A%B9%EC%88%98%ED%99%94\" aria-label=\"일반화와 특수화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>일반화와 특수화</h2>\n<ol>\n<li>\n<p>범주의 계층</p>\n<ul>\n<li>중세 유럽의 카를로스 린네의 생물 분류법은 ‘계’라는 최상위 단계가 있는 중첩된 계층 구조였음</li>\n<li>계-문-강-목-과-속-종의 분류에서 고양이종 범주는 포유류강 범주의 하위 범주에 속함. 얼룩고양이를 실제로 알지 못하더라도 얼룩고양이에게 (포유류처럼) 척추가 있고 새끼를 낳아 기르며 젖을 먹여 새끼를 기를 것이라는 사실을 쉽게 추론할 수 있음</li>\n<li>린네의 분류 체계는 범주 간의 계층적인 구조를 가짐.</li>\n<li>린네의 계층 구조에서 계층의 상위에 위치한 범주를 계층의 하위 범주의 일반화 라고 하고, 계층의 하위에 위치한 범주는 계층의 상위 범주의 특수화 라고 함</li>\n</ul>\n</li>\n<li>\n<p>서브타입</p>\n<ul>\n<li>어떤 타입이 다른 타입보다 일반적이라면 이 타입을 슈퍼타입(supertype) 이라고 하며, 어떤 타입이 다른 타입보다 좀 더 특수하다면 이 타입을 서브타입(subtype) 이라고 험. 슈퍼타입은 서브타입의 일반화이고 서브타입은 슈퍼타입의 특수화</li>\n<li>슈퍼타입은 서브타입의 일반화이고 서브타입은 슈퍼타입의 특수화</li>\n<li>아리스토텔레스의 분류법에서는 기존의 범주가 가진 속성을 새로운 범주가 포함할 경우 새로운 범주는 기존의 범주를 확장해 정의할 수 있음.</li>\n<li>이것은 객체지향의 세계에서도 동일하게 적용됨. 서브타입은 슈퍼타입이 가진 본질적인 속성과 함께 자신만의 추가적인 속성을 가짐</li>\n<li>서브타입은 슈퍼타입의 본질적인 속성을 모두 포함하기 때문에 계층에 속하는 모든 서브타입들은 슈퍼타입의 속성을 공유함.</li>\n<li>외연의 관점에서 서브타입은 슈퍼타입의 부분집합으로 표현됨. (종 &#x3C; 속 &#x3C; 과 &#x3C; 목 &#x3C; 강 &#x3C; 문 &#x3C; 계)</li>\n<li>(린네의 분류체계에서는 ‘계’로 갈수록 슈퍼타입, ‘종’으로 갈수록 서브타입)</li>\n<li>모든 고양이는 육식동물의 집합에 포함되며, 모든 육식동물은 포유류의 집합에 포함됨. 따라서 고양이의 집합은 육식동물의 부분집합이며, 육식동물의 집합은 포유류의 부분집합</li>\n<li>어떤 타입이 다른 타입의 서브타입이 되기 위해서는 ‘100% 규칙’ 과 ‘is-a 규칙’ 을 준수해야 함</li>\n<li>100% 규칙: 슈퍼타입의 정의가 100% 서브타입에 적용돼야만 함</li>\n<li>is-a 규칙: 서브타입의 모든 인스턴스는 슈퍼타입 집합에 포함돼야 함</li>\n<li>흔히 일반화 관계를 is-a 관계라고 함</li>\n<li>“고양이는 육식동물이다 (O)”와 “육식동물은 고양이다 (X)” → 두 가지 범주 간의 일반화 관계를 표현함</li>\n<li>모든 고양이 인스턴스들은 육식동물에 해당함</li>\n</ul>\n</li>\n<li>\n<p>상속</p>\n<ul>\n<li>일반화와 특수화 관계를 구현하는 가장 일반적인 방법은 클래스 간 상속을 사용하는 것이지만, 모든 상속 관계가 일반화 관계인 것은 아님.</li>\n<li>일반화의 원칙은 한 타입이 다른 타입의 서브타입이 되기 위해서는 슈퍼타입에 순응(conformance) 해야 한다는 것.</li>\n<li>이는 특정 기대 집합에 대해 서브타입의 슈퍼타입에 대한 대체 가능성을 의미함</li>\n<li>\n<p>구조적인 순응</p>\n<ul>\n<li>서브타입은 슈퍼타입이 가지고 있는 속성과 연관관계 면에서 100% 일치해야 한다는 것</li>\n<li>Person이 name이라는 속성을 가진다면 Person의 서브타입인 Employee 역시 name이라는 속성을 가질 것이라고 기대할 수 있음. Employee는 Person을 대체할 수 있음</li>\n</ul>\n</li>\n<li>\n<p>행위적인 순응</p>\n<ul>\n<li>서브타입은 슈퍼타입을 행위적으로 대체 가능해야 함. 이를 흔히 리스코프 치환 원칙이라고 함</li>\n<li>Person이 getAge()라는 메시지에 대한 응답으로 나이를 반환한다면 서브타입인 Employee 역시 getAge()라는 메시지에 대한 응답으로 나이를 반환해야 함.</li>\n</ul>\n</li>\n<li>\n<p>상속은 서브타이핑(subtyping) 과 서브클래싱(subclassing) 의 두 가지 용도로 사용될 수 있음</p>\n<ul>\n<li>서브타이핑: 서브클래스가 슈퍼클래스를 대체할 수 있는 경우 (타입을 상속)</li>\n<li>서브클래싱: 서브클래스가 슈퍼클래스를 대체할 수 없고 단지 코드만 공유하고 있는 경우 (클래스를 상속)</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// 서브타이핑</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">MyClass</span> <span class=\"token punctuation\">{</span>\n  String <span class=\"token function\">Name</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\"><span class=\"token constant\">A</span></span><span class=\"token operator\">:</span> MyClass <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">public</span> String <span class=\"token function\">Name</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token string\">\"Class name is A\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\"><span class=\"token constant\">B</span></span><span class=\"token operator\">:</span> MyClass <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">public</span> String <span class=\"token function\">Name</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token string\">\"Class name is B\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">PrintName</span><span class=\"token punctuation\">(</span>MyClass obj<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  Console<span class=\"token punctuation\">.</span><span class=\"token function\">WriteLine</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">.</span><span class=\"token function\">Name</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">Main</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  MyClass objA <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token constant\">A</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  MyClass objB <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token constant\">B</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">PrintName</span><span class=\"token punctuation\">(</span>objA<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// Class name is A</span>\n  <span class=\"token function\">PrintName</span><span class=\"token punctuation\">(</span>objB<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// Class name is B</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// 서브클래싱</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\"><span class=\"token constant\">A</span></span>  <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">public</span> String <span class=\"token function\">Name</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token string\">\"Class name is A\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\"><span class=\"token constant\">B</span></span><span class=\"token operator\">:</span> <span class=\"token constant\">A</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">public</span> String <span class=\"token function\">Name</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token string\">\"Class name is B\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">PrintName</span><span class=\"token punctuation\">(</span><span class=\"token constant\">A</span> obj<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  Console<span class=\"token punctuation\">.</span><span class=\"token function\">WriteLine</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">.</span><span class=\"token function\">Name</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">Main</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token constant\">A</span> objA <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token constant\">A</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token constant\">A</span> objB <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token constant\">B</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">PrintName</span><span class=\"token punctuation\">(</span>objA<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// Class name is A</span>\n  <span class=\"token function\">PrintName</span><span class=\"token punctuation\">(</span>objB<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// Class name is A</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 클래스 상속은 부모 클래스의 코드를 재사용하기 때문에 위와 같이 슈퍼클래스의 객체를 하위클래스의 객체로 대체하더라도 하위 클래스의 행동으로 대체되어 동작하지 않는다</span>\n<span class=\"token comment\">// 메소드 재정의(method overriding)를 통해 부모 클래스의 메소드를 대체해야 한다.</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\"><span class=\"token constant\">B</span></span><span class=\"token operator\">:</span> <span class=\"token constant\">A</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">public</span> override String <span class=\"token function\">Name</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token string\">\"Class name is B\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li><a href=\"https://epicdevsold.tistory.com/177\">객체지향 상속의 종류: 서브클래싱과 서브타이핑 (Subclassing &#x26; Subtyping)</a></li>\n<li>흔히 서브타이핑을 인터페이스 상속이라고 하고, 서브클래싱을 구현 상속이라고 함.</li>\n<li>여러 클래스로 구성된 상속 계층에서 수신된 메시지를 이해하는 기본적인 방법은 클래스 간의 위임(delegation) 을 사용하는 것</li>\n<li>어떤 객체의 클래스가 수신된 메시지를 이해할 수 없다면 메시지를 클래스의 부모 클래스로, 그리고 또 부모 클래스로 위임함</li>\n<li>프로토타입 기반 언어에서 상속은 객체와 객체 간의 관계로 이뤄지며, 메시지 역시 위임 메커니즘에 의해 처리됨.</li>\n<li>자식 객체와 부모 객체 사이 상속과 위임을 통해 관계를 연결함</li>\n</ul>\n</li>\n</ol>\n<br>\n<h2 id=\"집합과-분해\" style=\"position:relative;\"><a href=\"#%EC%A7%91%ED%95%A9%EA%B3%BC-%EB%B6%84%ED%95%B4\" aria-label=\"집합과 분해 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>집합과 분해</h2>\n<ol>\n<li>\n<p>계층적인 복잡성</p>\n<ul>\n<li>복잡성은 ‘계층’의 형태를 띰</li>\n<li>단순한 형태로부터 복잡한 형태로 진화하는 데 걸리는 시간은 그 사이에 존재하는 ‘안정적인 형태’의 수와 분포에 의존함</li>\n<li>시계는 수많은 부품이 유기적으로 결합되어 부품들 간의 계층적인 형태를 취함. 시계를 짧은 시간 안에 효율적으로 조립하는 방법은 작은 부품으로 구성된 안정적인 형태의 중간 부품을 이용해서 조립하는 것. 시계는 전체적인 연쇄 계층 구조로 구성됨</li>\n<li>집합: 안정적인 형태의 부분으로부터 전체를 구축하는 행위</li>\n<li>분해: 전체를 부분으로 분할하는 행위</li>\n<li>집합은 전체의 내부로 불필요한 세부사항을 감춰주는 추상화 메커니즘이자 캡슐화 메커니즘</li>\n<li>집합과 분해는 한 번에 다뤄야 하는 요소의 수를 감소시킴으로써 인지 과부하를 방지함. 인간은 은유를 통해 쉽게 추상적인 경계를 찾으며, 인위적인 집합을 창조할 수 있음</li>\n</ul>\n</li>\n<li>\n<p>합성 관계</p>\n<ul>\n<li>객체와 객체 사이의 전체-부분 관계를 구현하기 위해서는 합성 관계를 사용함</li>\n<li>주문 항목은 반드시 어떤 한 주문의 일부로 생성되는 전체-부분 관계</li>\n<li>합성 관계는 부분을 전체 안에 캡슐화함으로써 인지 과부하를 방지함. 이 모델을 다루는 사람은 주문 항목과 관련된 세부 사항을 무시하고 주문과 상품이 존재하는 것처럼 모델을 다룰 수 있으며, 필요하다면 주문 내부로 들어가 주문 항목과 관련된 세부 사항을 확인할 수도 있음</li>\n<li>상품은 주문 항목의 일부가 아님</li>\n<li>주문 항목과 상품 간에는 단순한 물리적 통로만 존재함. 이를 연관 관계라고 함</li>\n<li>합성 관계는 연관 관계보다 더 강하게 객체들을 결합함</li>\n<li>일반적으로 합성 관계로 연결된 객체는 포함하는 객체가 제거될 때 내부에 포함된 객체도 함께 제거됨</li>\n<li>주문이 제거되면 주문 항목도 함께 제거됨</li>\n<li>반면 연관 관계로 연결된 두 객체는 독립적으로 제거될 수 있음</li>\n<li>주문과 주문 항목이 제거되더라도 상품은 계속 판매됨</li>\n</ul>\n</li>\n<li>\n<p>패키지</p>\n<ul>\n<li>소프트웨어의 구조를 단순화하기 위해서는 서로 관련성이 높은 클래스 집합을 논리적인 단위로 통합해야 함. 이렇게 묶는 구성 요소를 패키지(package) 또는 모듈(module) 이라고 함</li>\n<li>패키지를 이용하면 개별 클래스가 아닌 클래스의 집합을 캡슐화함으로써 전체적인 복잡도를 낮출 수 있으며, 함께 협력하는 응집도 높은 클래스 집합을 하나로 모아 패키지 경계 안에서 작업을 할 수 있음</li>\n<li>패키지는 내부의 클래스들을 추상화함</li>\n</ul>\n</li>\n</ol>\n<br>\n<h2 id=\"참고\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0\" aria-label=\"참고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고</h2>\n<ul>\n<li><a href=\"https://www.yes24.com/Product/Goods/18249021\">객체지향의 사실과 오해</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EC%B6%94%EC%83%81%ED%99%94-%EA%B8%B0%EB%B2%95\">추상화 기법</a></li>\n<li><a href=\"#%EB%B6%84%EB%A5%98%EC%99%80-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4%ED%99%94\">분류와 인스턴스화</a></li>\n<li><a href=\"#%EC%9D%BC%EB%B0%98%ED%99%94%EC%99%80-%ED%8A%B9%EC%88%98%ED%99%94\">일반화와 특수화</a></li>\n<li><a href=\"#%EC%A7%91%ED%95%A9%EA%B3%BC-%EB%B6%84%ED%95%B4\">집합과 분해</a></li>\n<li><a href=\"#%EC%B0%B8%EA%B3%A0\">참고</a></li>\n</ul>\n</div>","frontmatter":{"date":"December 20, 2023","title":"객체지향의 사실과 오해 - 기타","categories":"Study","author":"Kay","emoji":"👋"},"fields":{"slug":"/oop-fact-and-misunderstand-etc/"}},"site":{"siteMetadata":{"siteUrl":"https://free-ko.github.io","comments":{"utterances":{"repo":""}}}}},"pageContext":{"slug":"/write-log-231216/","nextSlug":"/oop-fact-and-misunderstand-6/","prevSlug":"/oop-fact-and-misunderstand-etc/"}},"staticQueryHashes":["1073350324","2938748437"]}