{"componentChunkName":"component---src-templates-blog-template-js","path":"/study-cs-HTTP-1/","result":{"data":{"cur":{"id":"7f9291af-1f09-59d9-ad5d-6be8c1c5edd7","html":"<br>\n<h1 align=\"center\">\n  👋  인터넷 네트워크\n</h1>\n<br>\n<h2 id=\"1-인터넷-통신\" style=\"position:relative;\"><a href=\"#1-%EC%9D%B8%ED%84%B0%EB%84%B7-%ED%86%B5%EC%8B%A0\" aria-label=\"1 인터넷 통신 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 인터넷 통신</h2>\n<ul>\n<li>클라이언트에서 특정 요청을 하면 서버에서 요청을 확인하고 다시 클라이언트에서 보내주는 방식.</li>\n<li>클라이언트와 서버를 연결해주는 무수한 연결망을 인터넷이라고 함.</li>\n</ul>\n<br>\n<h2 id=\"2-ipinternet-protocol\" style=\"position:relative;\"><a href=\"#2-ipinternet-protocol\" aria-label=\"2 ipinternet protocol permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. IP(Internet Protocol)</h2>\n<h3 id=\"1-ip-역할\" style=\"position:relative;\"><a href=\"#1-ip-%EC%97%AD%ED%95%A0\" aria-label=\"1 ip 역할 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1). IP 역할</h3>\n<ul>\n<li>클라이언트 IP와 서버 IP를 명시해서 정확한 위치에 원하는 요청을 함</li>\n<li>지정한 IP(IP Address)에 데이터 전달</li>\n<li>패킷(Packet)이라는 통신 단위로 데이터 전달\n—> 패킷은 약간 편지 같은거? 보내는사람, 받는 사람 적어서 보내는 것처럼 데이터를 전달 할 때 <code class=\"language-text\">규칙</code>이 존재</li>\n</ul>\n<h3 id=\"2-서버-패킷-전달\" style=\"position:relative;\"><a href=\"#2-%EC%84%9C%EB%B2%84-%ED%8C%A8%ED%82%B7-%EC%A0%84%EB%8B%AC\" aria-label=\"2 서버 패킷 전달 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2). 서버 패킷 전달</h3>\n<ul>\n<li>인터넷을 통해 서버(주소)에게 데이터를 전달하는데, 다시 서버에서 클라이언트에게 전달 될 때에는 같은 경로로 오지 않을 수 있음</li>\n</ul>\n<h3 id=\"3-ip-프로토콜의-한계--tcp-udp로-해결-가능\" style=\"position:relative;\"><a href=\"#3-ip-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EC%9D%98-%ED%95%9C%EA%B3%84--tcp-udp%EB%A1%9C-%ED%95%B4%EA%B2%B0-%EA%B0%80%EB%8A%A5\" aria-label=\"3 ip 프로토콜의 한계  tcp udp로 해결 가능 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3). IP 프로토콜의 한계 —> TCP, UDP로 해결 가능</h3>\n<ol>\n<li><code class=\"language-text\">비연결성</code> : 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송</li>\n<li><code class=\"language-text\">비신뢰성</code> : 중간에 패킷이 사라지면? 패킷이 순서대로 안오면?</li>\n<li><code class=\"language-text\">프로그램 구분</code> : 같은 IP를 사용하는 서버에서 통신하는 App이 둘 2상이면?</li>\n</ol>\n<br>\n<h2 id=\"3-tcp-udp\" style=\"position:relative;\"><a href=\"#3-tcp-udp\" aria-label=\"3 tcp udp permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. TCP, UDP</h2>\n<h3 id=\"1-tcp-특징\" style=\"position:relative;\"><a href=\"#1-tcp-%ED%8A%B9%EC%A7%95\" aria-label=\"1 tcp 특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1). TCP 특징</h3>\n<ol>\n<li>연결 지향 - TCP 3 Way HandShake(가상 연결) : 실제로 연결되지 않고 명목상으로 서버랑 연결했다고 이야기하는 것 사실 그 과정에 많은 서버(노드)가 존재함</li>\n<li>데이터 전달 보증</li>\n<li>순서 보장</li>\n<li>신뢰 할 수 있는 프로토콜</li>\n<li>현재는 대부분 TCP 사용</li>\n</ol>\n<br>\n<h3 id=\"2-udp\" style=\"position:relative;\"><a href=\"#2-udp\" aria-label=\"2 udp permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2). UDP</h3>\n<ol>\n<li>하얀 도화지에 비유(기능이 거의 없음)</li>\n<li>연결 지향 X</li>\n<li>데이터 전달 보증 X</li>\n<li>순서 보장 X</li>\n<li>데이터 전달 및 순서가 보장되지 않지만, 단순하고 빠름</li>\n<li>IP와 거의 같음 + PORT + 체크섬 정도만 추가</li>\n<li>애플리케이션에서 추가 작업 필요</li>\n</ol>\n<br>\n<h2 id=\"4-port\" style=\"position:relative;\"><a href=\"#4-port\" aria-label=\"4 port permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. PORT</h2>\n<ol>\n<li>IP는 아파트, PORT는 동, 호수라고 생각하면 됨</li>\n<li>\n<p>IP에 추가로 각각의 PORT 존재</p>\n<p>ex) <code class=\"language-text\">클라이언트 IP</code>: 100.100.100.1 PORT 8080 —> <code class=\"language-text\">서버 IP</code>: 200.200.200.2 PORT 1120 이런식으로 보냄</p>\n</li>\n<li>\n<p>PORT 번호</p>\n<ol>\n<li>0 ~ 65535 할당가능</li>\n<li>0 ~ 1023: 잘 알려진 포트, 사용하지 않는 것이 좋음</li>\n<li>FTP : 20, 21</li>\n<li>TELNET : 23</li>\n<li>HTTP : 80</li>\n<li>HTTPS : 443</li>\n</ol>\n</li>\n</ol>\n<br>\n<h2 id=\"5-dns\" style=\"position:relative;\"><a href=\"#5-dns\" aria-label=\"5 dns permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. DNS</h2>\n<ul>\n<li>\n<p>도메인 네임 시스템 = Domain Name System</p>\n<ul>\n<li>ex) 전화번호부, 도메인 명을 IP주소로 변환</li>\n</ul>\n</li>\n</ul>\n<deckgo-highlight-code language=\"toc\"  >\n          <code slot=\"code\"></code>\n        </deckgo-highlight-code>","excerpt":"1. 인터넷 통신 클라이언트에서 특정 요청을 하면 서버에서 요청을 확인하고 다시 클라이언트에서 보내주는 방식. 클라이언트와 서버를 연결해주는 무수한 연결망을 인터넷이라고 함. 2. IP(Internet Protocol) 1). IP 역할 클라이언트 IP와 서버 IP를 명시해서 정확한 위치에 원하는 요청을 함 지정한 IP(IP Address)에 데이터 전달 패킷(Packet)이라는 통신 단위로 데이터 전달\n—> 패킷은 약간 편지 같은거? 보내는사람, 받는 사람 적어서 보내는 것처럼 데이터를 전달 할 때 이 존재 2). 서버 패킷 전달 인터넷을 통해 서버(주소)에게 데이터를 전달하는데, 다시 서버에서 클라이언트에게 전달 될 때에는 같은 경로로 오지 않을 수 있음 3). IP 프로토콜의 한계 —> TCP, UDP로 해결 가능  : 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송  : 중간에 패킷이 사라지면? 패킷이 순서대로 안오면?  : 같은 IP를 사용하는 서버에서 통신하는…","frontmatter":{"date":"December 11, 2021","title":"HTTP - 1.인터넷 네트워크","categories":"CS","author":"우기","emoji":"👨‍💻"},"fields":{"slug":"/study-cs-HTTP-1/"}},"next":{"id":"79fbe71b-5c10-56ac-ab4d-1316c99ce12d","html":"<br>\n<h1 align=\"center\">\n  👋 getPrototypeof(), setPrototypeof(), ownKeys(), getOwnPropertyDescriptor()\n</h1>\n<br>\n<h2 id=\"1-getprototypeof\" style=\"position:relative;\"><a href=\"#1-getprototypeof\" aria-label=\"1 getprototypeof permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. getPrototypeOf()</h2>\n<ul>\n<li>\n<p><code class=\"language-text\">target.__proto__</code>를 반환 함</p>\n<ul>\n<li><code class=\"language-text\">target</code> 이 확장 불가라도 반환함</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">Relflect.getPrototypeOf()</code> 형태로 작성</p>\n<deckgo-highlight-code language=\"tsx\"  >\n          <code slot=\"code\">let proto = Reflect.getPrototypeOf(Array);\nconsole.log(proto === Function.prototype);   // true\nconsole.log(proto === Array.prototype);      // flase\n\nconst list = [];\nproto = Reflect.gePrototypeOf(list);\nconsole.log((proto === Array.prototype);     // true\n\n// 1. let proto = Reflect.getPrototypeOf(Array); Array 오브젝트의 __proto__를 반환함\n// 2. Array.prototype에 Array 오브젝트의 메소드가 있으며 Array.__proto__에 Function.prototype의 메소드가 있음\n// 3. __proto__를 반환하므로 Function.prototype이 반환됨\n// 4. 사용하는 오브젝트의 prototype과 __proto__ 구조가 연상되어야 함\n// 5. proto === Function.prototype: true를 반환함\n// 6. proto === Array.prototype: false를 반환함\n// 7. const list = []; Array 인스턴스를 생성하면, list.__proto__에 Array.prototype의 메소드가 있음\n// 8. proto = Relfect.getPrototypeOf(this); proto에 list.__proto__가 할당됨\n// 9. console.log(proto === Array.prototype) proto와 Array.prototype이 같음</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p><code class=\"language-text\">prototype</code> 의 <code class=\"language-text\">__proto__</code> 를 반환</p>\n<deckgo-highlight-code language=\"tsx\"  >\n          <code slot=\"code\">const proto = Reflect.getPrototypeOf(Array.prototype);\n\nconsole.log(proto.map); // undefined\nconsole.log(proto.hasOwnProperty); // function hasOwnProperty() {[native code]}\n\n// 1. Reflect.getPrototypeOf(Array.prototype), Array.prototype.__proto__을 반환함, 여기에 빌트인 Object.prototype의 메소드가 있음\n// 2. console.log(proto.map) map()은 Array.prototype에 있으므로 undefined가 반환됨\n// 3. console.log(proto.hasOwnProperty) hasOwnProperty()는 Object.prototype의 메소드로 Array.prototype.__proto__에 있음</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<br>\n<h2 id=\"2-setprototypeof\" style=\"position:relative;\"><a href=\"#2-setprototypeof\" aria-label=\"2 setprototypeof permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. setPrototypeof()</h2>\n<ul>\n<li><code class=\"language-text\">target.__proto__</code>에 <code class=\"language-text\">prototype</code>에 연결된 메소드를 설정함</li>\n<li>\n<p><code class=\"language-text\">Reflect.setPrototypeOf()</code> 형태로 작성</p>\n<deckgo-highlight-code language=\"tsx\"  >\n          <code slot=\"code\">class Point {\ngetPoint() {\n  return 100;\n}\n}\n\nconst target = function () {};\ntarget.prototype.getPoint = function () {\nreturn 200;\n};\n\nReflect.setPrototypeOf(target, Point.prototype);\nconsole.log(target.getPoint()); // 100\n\n// 1. Reflect.setPrototypeOf(target, Point.prototype); targt의 __proto__에 Point.prototype에 연결된 메소드를 설정함\n// 2. console.log(target.getPoint()) target.__proto__의 getPoint()가 호출됨, target.prototype.getPoint()가 호출되지 않음</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<br>\n<h2 id=\"3-ownkeys\" style=\"position:relative;\"><a href=\"#3-ownkeys\" aria-label=\"3 ownkeys permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. ownKeys()</h2>\n<ul>\n<li>\n<p><code class=\"language-text\">target</code> 의 모든 프로퍼티 키를 배열로 반환함</p>\n<ul>\n<li><code class=\"language-text\">[[Configurable]]: false</code> 이거나 오브젝트가 확장 불가라도 반환함</li>\n<li>상속 받은 프로퍼티는 제외 함</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">Reflect.ownKeys()</code> 형태로 작성</p>\n<deckgo-highlight-code language=\"tsx\"  >\n          <code slot=\"code\">const sym = Symbol(&#39;심볼&#39;);\nconst target = {};\nObject.defineProperties(target, {\npoint: { value: 100, configurable: false },\n[sym]: { value: 200 },\n});\n\nReflect.preventExtensions(target);\nconsole.log(Reflect.ownKeys(target)); // [point, Symbol(심볼)]\n\n// 1. console.log(Reflect.ownKeys(target)) target 오브젝트가 확장 불가이지만 모든 프로퍼티 키를 배열로 반환함, Symbol도 반환함</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<br>\n<h2 id=\"4-getownpropertydescriptor\" style=\"position:relative;\"><a href=\"#4-getownpropertydescriptor\" aria-label=\"4 getownpropertydescriptor permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. getOwnPropertyDescriptor()</h2>\n<ul>\n<li>\n<p><code class=\"language-text\">target</code> 에서 프로퍼티 디스크립터를 반환함</p>\n<ul>\n<li>상속 받은 프로퍼티는 제외 함</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">Reflect.getOwnPropertyDescriptor()</code> 형태로 작성</p>\n<deckgo-highlight-code language=\"tsx\"  >\n          <code slot=\"code\">const target = {};\nObject.defineProperty(target, &#39;point&#39;, {\nvalue: 100,\nconfigurable: true,\n});\n\nconst desc = Reflect.getOwnPropertyDescriptor(target, &#39;point&#39;);\n\nconsole.log(desc); // {value: 100, writable: false, enumerable: false, configurable: treu}\n\n// 1. Reflect.getOwnPropertyDescriptor(target, &quot;point&quot;); target에 {value: 100, configurable: true}를 작성했지만 디폴트 속성도 반환함</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<deckgo-highlight-code language=\"toc\"  >\n          <code slot=\"code\"></code>\n        </deckgo-highlight-code>","frontmatter":{"date":"December 10, 2021","title":"Reflect - getPrototypeof(), setPrototypeof(), ownKeys(), getOwnPropertyDescriptor()","categories":"JS","author":"우기","emoji":"👨‍💻"},"fields":{"slug":"/study-js-es6-reflect-6/"}},"prev":{"id":"91d21ee4-cd28-550e-9451-cbef0ab783f4","html":"<br>\n<h1 align=\"center\">\n  👋 construct(), apply()\n</h1>\n<br>\n<h2 id=\"1-constructo\" style=\"position:relative;\"><a href=\"#1-constructo\" aria-label=\"1 constructo permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. constructo()</h2>\n<ul>\n<li>인스턴스를 생성하여 반환함</li>\n<li>\n<p><code class=\"language-text\">Reflect.construct(target, params)</code> 형태</p>\n<deckgo-highlight-code language=\"tsx\"  >\n          <code slot=\"code\">class Point {\nconstructor(one, two) {\n  this.point = one + two;\n}\n}\n\nconst obj = Reflect.construct(Point, [100, 200]);\nconsole.log(obj.point); // 300\n\n// 1. Reflect.construct(Point, [100, 200], Point 클래스의 constructor()를 호출 함, [100]처럼 값이 하나라도 배열로 작성함\n// 2. constructor(one, two){...} 100이 one에 200이 two에 설정됨\n// 3. Point 인스턴스를 생성하여 반환함</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>세 번째 파라미터는 선택임</p>\n<ul>\n<li>생성자 함수를 작성함</li>\n<li>작성한 함수로 인스턴스를 생성함</li>\n</ul>\n<deckgo-highlight-code language=\"tsx\"  >\n          <code slot=\"code\">class Point {\n  constructor(point) {\n    this.point = point;\n  }\n\n  getPoint() {\n    return this.point;\n  }\n}\n\nclass Book {\n  getTitle() {\n    return &#39;JS: &#39; + this.point;\n  }\n}\n\nconst obj = Reflect.construct(Point, [100], Book);\n\nconsole.log(obj.getPoint); // undefined\nconsole.log(obj.getTitle()); // JS: 100\n\n// 1. Reflect.construct(Point, [100], Book); 3번째 파라미터에 Book 클래스를 작성함, Point 클래스의 constructor가 호출됨\n// 2. constructor(point){ this.point = point; } Point가 아니라 Book으로 인스턴스를 생성함, this가 Book 클래스를 참조함\n// 3. this.point = point; point가 인스턴스 프로퍼티로 설정됨\n// 4. 외부 API 사용처럼 변경할 수 없는 환경에서 클래스의 프로퍼티를 인스턴스 프로퍼티로 사용하면서 클래스의 prototype을 오버라이드하는 형태로 사용할 수 있음\n// 5. obj.getPoint, obj 인스턴스에 getPoint()가 없으므로 undefined 출력\n// 6. obj.getTitle() Bookd의 getTitle()이 호출됨</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p><code class=\"language-text\">핸들러의 constrcut()</code> 트랩 호출</p>\n<deckgo-highlight-code language=\"tsx\"  >\n          <code slot=\"code\">class Point {\nconstructor(...point) {\n  this.point = point;\n}\n\ngetPoint() {\n  return this.point;\n}\n}\n\nconst handler = {\nconstruct(target, params, proxy) {\n  return Reflect.construct(target, params);\n},\n};\n\nconst proxy = new Proxy(Point, handler);\nconst obj = Reflect.construct(proxy, [1, 2]);\nconsole.log(obj.getPoint()); // [1, 2]\n\n// 1. const obj = Reflect.construct(proxy, [1, 2]); construct() 트랩이 호출됨\n// 2. 트랩: construct(target, params, proxy) {...} Point 클래스가 target에 [1, 2]가 params에 설정됨, proxy에 Proxy 인스턴스가 설정됨</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<br>\n<h2 id=\"2-apply\" style=\"position:relative;\"><a href=\"#2-apply\" aria-label=\"2 apply permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. apply()</h2>\n<ul>\n<li><code class=\"language-text\">target</code> 에 작성한 함수를 호출함</li>\n<li>\n<p><code class=\"language-text\">Relfect.apply(target, {}, key)</code> 형태</p>\n<deckgo-highlight-code language=\"tsx\"  >\n          <code slot=\"code\">function add(...values) {\nreturn values.map((value) =&gt; {\n  return value + this.plus;\n});\n}\n\nconsole.log(Reflect.apply(add, { plus: 100 }, [1, 2])); // [101, 102]\n\n// 1. Reflect.apply(add, {plus: 100}, [1,2]) add() 함수를 호출함\n// 2. function add(...values){...} [1,2]가 values 파라미터에 설정됨\n// 3. map()에서 this가 {plus: 100}을 참조함, 코드처럼 화살표 함수를 사용해야 함, map(function(value){...}) 형태는 this가 window를 참조함</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p><code class=\"language-text\">call(), apply()</code> 통합</p>\n<deckgo-highlight-code language=\"tsx\"  >\n          <code slot=\"code\">const indexOf = String.prototype.indexOf;\n\nconsole.log(indexOf.call(&#39;ABC&#39;, &#39;B&#39;)); // 1\nconsole.log(Reflect.apply(indexOf, &#39;ABC&#39;, [&#39;B&#39;])); // 1\n\n// 1. const indexOf = String.prototype.indexOf; String.prototype.indexOf() 메소드 임\n// 2. call()로 호출 indexOf.call(&quot;ABC&quot;, &quot;B&quot;);\n// 3. Reflect.apply()로 호출, Reflect.apply(indexOf, &quot;ABC&quot;, [&quot;B&quot;]) call()과 apply()를 통합하여 Reflect.apply()로 호출함</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>핸들러의 <code class=\"language-text\">apply()</code> 트랩 호출</p>\n<deckgo-highlight-code language=\"tsx\"  >\n          <code slot=\"code\">function add(...values) {\nreturn values.map((value) =&gt; {\n  return value + this.plus;\n});\n}\n\nconst handler = {\napply(target, that, params) {\n  return Reflect.apply(target, that, params);\n},\n};\n\nconst obj = new Proxy(add, handler);\n\nconsole.log(obj.apply({ plus: 100 }, [1, 2])); // [101, 102]\n\n// 1. const obj = new Proxy(add, handler); add가 apply() 트랩에서 호출할 함수임\n// 2. obj.apply({plus: 100}, [1, 2]) apply() 트랩이 호출 됨\n// 3. 트랩: apply(target, that, params) {...}, add() 함수가 target에 설정됨 {plus:100}이 that에 설정되고 [1,2]가 params에 설정됨</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<deckgo-highlight-code language=\"toc\"  >\n          <code slot=\"code\"></code>\n        </deckgo-highlight-code>","frontmatter":{"date":"December 11, 2021","title":"Reflect - construct(), apply()","categories":"JS","author":"우기","emoji":"👨‍💻"},"fields":{"slug":"/study-js-es6-reflect-7/"}},"site":{"siteMetadata":{"siteUrl":"https://free-ko.github.io","comments":{"utterances":{"repo":"zoomkoding/zoomkoding-gatsby-blog"}}}}},"pageContext":{"slug":"/study-cs-HTTP-1/","nextSlug":"/study-js-es6-reflect-6/","prevSlug":"/study-js-es6-reflect-7/"}},"staticQueryHashes":["1073350324","2938748437"]}